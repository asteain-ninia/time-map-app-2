// src/domain/services/GeometryService.js
import { Coordinate } from '../value-objects/Coordinate';

/**
 * 幾何学計算を提供するドメインサービス
 */
export class GeometryService {
  /**
   * 2点間の距離を計算
   * @param {number} x1 - 点1のX座標
   * @param {number} y1 - 点1のY座標
   * @param {number} x2 - 点2のX座標
   * @param {number} y2 - 点2のY座標
   * @returns {number} 2点間の距離
   */
  calculateDistance(x1, y1, x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    return Math.sqrt(dx * dx + dy * dy);
  }

  /**
   * 2点間の直線距離を計算（キロメートル単位）
   * @param {number} x1 - 点1のX座標
   * @param {number} y1 - 点1のY座標
   * @param {number} x2 - 点2のX座標
   * @param {number} y2 - 点2のY座標
   * @param {number} equatorLength - 赤道長（km）
   * @returns {number} 2点間の距離（km）
   */
  calculateLinearDistanceInKm(x1, y1, x2, y2, equatorLength) {
    // 正距円筒図法に基づく距離計算
    // X座標は経度、Y座標は緯度に対応
    
    // 経度1度あたりの距離
    const degreeLengthAtEquator = equatorLength / 360;
    
    // 緯度1度あたりの距離（一定）
    const latitudeDegreeLength = equatorLength / 360;
    
    // 実際の経度の差（横方向）
    const dx = Math.abs(x2 - x1);
    
    // 実際の緯度の差（縦方向）
    const dy = Math.abs(y2 - y1);
    
    // 横方向の距離計算（緯度による経度距離の補正）
    // 緯度の平均値を使用して余弦補正を適用
    const avgLat = (y1 + y2) / 2;
    const cosLat = Math.cos(avgLat * Math.PI / 180);
    const xDistance = dx * degreeLengthAtEquator * cosLat;
    
    // 縦方向の距離計算
    const yDistance = dy * latitudeDegreeLength;
    
    // 直線距離の計算
    return Math.sqrt(xDistance * xDistance + yDistance * yDistance);
  }

  /**
   * 2点間の大円距離を計算（キロメートル単位）
   * @param {number} lon1 - 点1の経度
   * @param {number} lat1 - 点1の緯度
   * @param {number} lon2 - 点2の経度
   * @param {number} lat2 - 点2の緯度
   * @param {number} earthRadius - 地球の半径（km）
   * @returns {number} 2点間の大円距離（km）
   */
  calculateGreatCircleDistance(lon1, lat1, lon2, lat2, earthRadius = 6371) {
    // 緯度経度をラジアンに変換
    const dLat = this._toRadians(lat2 - lat1);
    const dLon = this._toRadians(lon2 - lon1);
    
    const a = 
      Math.sin(dLat / 2) * Math.sin(dLat / 2) +
      Math.cos(this._toRadians(lat1)) * Math.cos(this._toRadians(lat2)) * 
      Math.sin(dLon / 2) * Math.sin(dLon / 2);
    
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return earthRadius * c;
  }

  /**
   * 度をラジアンに変換
   * @param {number} degrees - 度数
   * @returns {number} ラジアン
   * @private
   */
  _toRadians(degrees) {
    return degrees * Math.PI / 180;
  }

  /**
   * 多角形の面積を計算
   * @param {Vertex[]} vertices - 頂点の配列
   * @returns {number} 多角形の面積
   */
  calculatePolygonArea(vertices) {
    if (vertices.length < 3) return 0;
    
    let area = 0;
    for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
      area += (vertices[j].x + vertices[i].x) * (vertices[j].y - vertices[i].y);
    }
    
    return Math.abs(area / 2);
  }

  /**
   * 多角形の面積をキロメートル単位で計算
   * @param {Vertex[]} vertices - 頂点の配列
   * @param {number} equatorLength - 赤道長（km）
   * @returns {number} 多角形の面積（km²）
   */
  calculatePolygonAreaInKm2(vertices, equatorLength) {
    if (vertices.length < 3) return 0;
    
    // 基本的な面積を計算
    const areaInPixels = this.calculatePolygonArea(vertices);
    
    // 緯度1度あたりの距離（km）
    const latDegreeLength = equatorLength / 360;
    
    // 面積の計算（緯度による経度の長さの変化を考慮）
    // 簡易計算として平均緯度を使用
    let avgLat = 0;
    for (const vertex of vertices) {
      avgLat += vertex.y;
    }
    avgLat /= vertices.length;
    
    // 緯度による距離の補正係数（余弦）
    const cosLat = Math.cos(avgLat * Math.PI / 180);
    
    // 1平方ピクセルあたりの面積（km²）
    const pixelAreaInKm2 = (latDegreeLength * latDegreeLength) * cosLat;
    
    return areaInPixels * pixelAreaInKm2;
  }

  /**
   * 2つの線分が交差するかどうかをチェック
   * @param {Coordinate} p1 - 線分1の始点
   * @param {Coordinate} p2 - 線分1の終点
   * @param {Coordinate} q1 - 線分2の始点
   * @param {Coordinate} q2 - 線分2の終点
   * @returns {boolean} 線分が交差すればtrue
   */
  doLineSegmentsIntersect(p1, p2, q1, q2) {
    const dx1 = p2.x - p1.x;
    const dy1 = p2.y - p1.y;
    const dx2 = q2.x - q1.x;
    const dy2 = q2.y - q1.y;
    
    const denominator = (dy2 * dx1 - dx2 * dy1);
    if (denominator === 0) return false; // 平行
    
    const ua = ((dx2 * (p1.y - q1.y)) - (dy2 * (p1.x - q1.x))) / denominator;
    const ub = ((dx1 * (p1.y - q1.y)) - (dy1 * (p1.x - q1.x))) / denominator;
    
    return (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1);
  }

  /**
   * 点が多角形内部にあるかをチェック
   * @param {Coordinate} point - チェックする点
   * @param {Coordinate[]} polygonVertices - 多角形の頂点配列
   * @returns {boolean} 点が多角形内部にあればtrue
   */
  isPointInPolygon(point, polygonVertices) {
    if (polygonVertices.length < 3) return false;
    
    let inside = false;
    for (let i = 0, j = polygonVertices.length - 1; i < polygonVertices.length; j = i++) {
      const xi = polygonVertices[i].x;
      const yi = polygonVertices[i].y;
      const xj = polygonVertices[j].x;
      const yj = polygonVertices[j].y;
      
      const intersect = ((yi > point.y) !== (yj > point.y)) && 
                        (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
      
      if (intersect) inside = !inside;
    }
    
    return inside;
  }

  /**
   * 多角形と多角形が重なるかどうかをチェック
   * @param {Coordinate[]} polygon1Vertices - 多角形1の頂点配列
   * @param {Coordinate[]} polygon2Vertices - 多角形2の頂点配列
   * @returns {boolean} 多角形が重なればtrue
   */
  doPolygonsOverlap(polygon1Vertices, polygon2Vertices) {
    // 1. エッジの交差をチェック
    for (let i = 0, j = polygon1Vertices.length - 1; i < polygon1Vertices.length; j = i++) {
      const p1 = polygon1Vertices[j];
      const p2 = polygon1Vertices[i];
      
      for (let k = 0, l = polygon2Vertices.length - 1; k < polygon2Vertices.length; l = k++) {
        const q1 = polygon2Vertices[l];
        const q2 = polygon2Vertices[k];
        
        if (this.doLineSegmentsIntersect(p1, p2, q1, q2)) {
          return true;
        }
      }
    }
    
    // 2. 一方が他方に完全に含まれているかチェック
    if (this.isPointInPolygon(polygon1Vertices[0], polygon2Vertices) ||
        this.isPointInPolygon(polygon2Vertices[0], polygon1Vertices)) {
      return true;
    }
    
    return false;
  }

  /**
   * 点をエッジに投影する（滑り機能のため）
   * @param {Coordinate} point - 投影する点
   * @param {Coordinate} edgeStart - エッジの始点
   * @param {Coordinate} edgeEnd - エッジの終点
   * @returns {Coordinate} エッジ上の最近接点
   */
  projectPointToEdge(point, edgeStart, edgeEnd) {
    const edgeVector = {
      x: edgeEnd.x - edgeStart.x,
      y: edgeEnd.y - edgeStart.y
    };
    
    const pointVector = {
      x: point.x - edgeStart.x,
      y: point.y - edgeStart.y
    };
    
    // エッジベクトルへの射影
    const edgeLength = Math.sqrt(
      edgeVector.x * edgeVector.x + edgeVector.y * edgeVector.y
    );
    
    if (edgeLength === 0) return new Coordinate(edgeStart.x, edgeStart.y);
    
    const dotProduct = 
      pointVector.x * edgeVector.x + pointVector.y * edgeVector.y;
    
    const projectionRatio = Math.max(0, Math.min(1, dotProduct / (edgeLength * edgeLength)));
    
    // 投影点の座標を計算
    return new Coordinate(
      edgeStart.x + projectionRatio * edgeVector.x,
      edgeStart.y + projectionRatio * edgeVector.y
    );
  }
}

// src/domain/services/TimeService.js
import { TimePoint } from '../value-objects/TimePoint';

/**
 * 時間操作と時間依存データの取得を担当するドメインサービス
 */
export class TimeService {
  /**
   * 時間サービスを作成
   * @param {Object} customCalendarConfig - カスタムカレンダー設定（省略可能）
   */
  constructor(customCalendarConfig = null) {
    // デフォルトのカレンダー設定
    this._calendarConfig = customCalendarConfig || {
      daysPerYear: 365.25,   // 1年の日数
      monthsPerYear: 12,     // 1年の月数
      daysPerMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] // 各月の日数
    };
  }

  /**
   * カスタムカレンダー設定を取得
   * @returns {Object} カレンダー設定
   */
  get calendarConfig() {
    return { ...this._calendarConfig };
  }

  /**
   * カスタムカレンダー設定を更新
   * @param {Object} newConfig - 新しいカレンダー設定
   */
  updateCalendarConfig(newConfig) {
    this._calendarConfig = { ...newConfig };
  }

  /**
   * 時間点が特定の範囲内にあるかチェック
   * @param {TimePoint} timePoint - チェックする時間点
   * @param {TimePoint} startTime - 開始時間（含む）
   * @param {TimePoint} endTime - 終了時間（含む）
   * @returns {boolean} 範囲内ならtrue
   */
  isWithinRange(timePoint, startTime, endTime) {
    return (!startTime || !startTime.isBefore(timePoint)) && 
           (!endTime || !timePoint.isBefore(endTime));
  }

  /**
   * 2つの時間点の間の日数を計算
   * @param {TimePoint} timePoint1 - 時間点1
   * @param {TimePoint} timePoint2 - 時間点2
   * @returns {number} 日数差（概算）
   */
  calculateDaysBetween(timePoint1, timePoint2) {
    // 基本的な年の差
    let yearDiff = timePoint2.year - timePoint1.year;
    
    // 月と日の差を計算
    let days = yearDiff * this._calendarConfig.daysPerYear;
    
    // 月が指定されている場合、月の差を計算
    if (timePoint1.month !== null && timePoint2.month !== null) {
      let monthDays1 = 0;
      let monthDays2 = 0;
      
      // 時間点1の月までの日数
      for (let i = 0; i < timePoint1.month - 1; i++) {
        monthDays1 += this._getMonthDays(i, timePoint1.year);
      }
      
      // 時間点2の月までの日数
      for (let i = 0; i < timePoint2.month - 1; i++) {
        monthDays2 += this._getMonthDays(i, timePoint2.year);
      }
      
      // 月による日数の調整
      days = yearDiff * this._calendarConfig.daysPerYear - monthDays1 + monthDays2;
      
      // 日が指定されている場合、日の差を計算
      if (timePoint1.day !== null && timePoint2.day !== null) {
        days += (timePoint2.day - timePoint1.day);
      }
    }
    
    return days;
  }

  /**
   * 指定された月の日数を取得
   * @param {number} monthIndex - 0基準の月インデックス
   * @param {number} year - 年
   * @returns {number} 指定された月の日数
   * @private
   */
  _getMonthDays(monthIndex, year) {
    if (this._calendarConfig.daysPerMonth) {
      const idx = monthIndex % this._calendarConfig.daysPerMonth.length;
      let days = this._calendarConfig.daysPerMonth[idx];
      
      // うるう年の2月（インデックス1）の処理
      if (idx === 1 && this._isLeapYear(year)) {
        days += 1;
      }
      
      return days;
    }
    
    // daysPerMonthが定義されていない場合の均等な割り当て
    return this._calendarConfig.daysPerYear / this._calendarConfig.monthsPerYear;
  }

  /**
   * うるう年かどうかを判定
   * @param {number} year - 判定する年
   * @returns {boolean} うるう年ならtrue
   * @private
   */
  _isLeapYear(year) {
    // 通常のグレゴリオ暦のうるう年ロジック
    // カスタムカレンダーの場合は、別のロジックを実装する必要がある
    return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);
  }

  /**
   * 時間点を特定の日数進める
   * @param {TimePoint} timePoint - 元の時間点
   * @param {number} days - 進める日数
   * @returns {TimePoint} 新しい時間点
   */
  advanceDays(timePoint, days) {
    // 基本実装 - 実際のアプリケーションではより複雑なロジックが必要
    // ここでは簡易的に実装
    const totalDays = days;
    let newYear = timePoint.year;
    let newMonth = timePoint.month;
    let newDay = timePoint.day;
    
    // 日単位で計算
    if (newDay !== null && newMonth !== null) {
      newDay += totalDays;
      
      // 月をまたぐ場合の処理
      while (newDay > this._getMonthDays(newMonth - 1, newYear)) {
        newDay -= this._getMonthDays(newMonth - 1, newYear);
        newMonth++;
        
        // 年をまたぐ場合の処理
        if (newMonth > this._calendarConfig.monthsPerYear) {
          newMonth = 1;
          newYear++;
        }
      }
    } else {
      // 日付が指定されていない場合は、年だけを進める
      newYear += Math.floor(totalDays / this._calendarConfig.daysPerYear);
    }
    
    return new TimePoint(newYear, newMonth, newDay);
  }
}

// src/domain/services/LayerService.js
/**
 * レイヤー間の関係管理を担当するドメインサービス
 */
export class LayerService {
  /**
   * レイヤーが正しい階層関係にあるかを検証
   * @param {Layer[]} layers - レイヤーの配列
   * @returns {boolean} 階層関係が正しければtrue
   */
  validateLayerHierarchy(layers) {
    // 順序の一意性をチェック
    const orders = layers.map(layer => layer.order);
    const uniqueOrders = new Set(orders);
    if (orders.length !== uniqueOrders.size) {
      return false;
    }
    
    // 順序が連続しているかをチェック
    orders.sort((a, b) => a - b);
    for (let i = 1; i < orders.length; i++) {
      if (orders[i] !== orders[i-1] + 1) {
        return false;
      }
    }
    
    return true;
  }

  /**
   * ポリゴンがレイヤー階層に従っているかを検証
   * @param {Polygon} polygon - 検証するポリゴン
   * @param {Polygon[]} allPolygons - すべてのポリゴンの配列
   * @param {Layer[]} layers - すべてのレイヤーの配列
   * @returns {boolean} 階層関係に従っていればtrue
   */
  validatePolygonHierarchy(polygon, allPolygons, layers) {
    // 最上位レイヤーのポリゴンは親を持たなくても良い
    const polygonLayer = layers.find(layer => layer.id === polygon.layerId);
    if (polygonLayer.order === 0 && polygon.parentId === "0") {
      return true;
    }
    
    // 親ポリゴンの存在確認
    if (polygon.parentId === "0") {
      return false; // 最上位レイヤー以外は親が必要
    }
    
    const parentPolygon = allPolygons.find(p => p.id === polygon.parentId);
    if (!parentPolygon) {
      return false; // 親ポリゴンが存在しない
    }
    
    // 親ポリゴンが上位レイヤーにあることを確認
    const parentLayer = layers.find(layer => layer.id === parentPolygon.layerId);
    return parentLayer.order < polygonLayer.order;
  }

  /**
   * 下位ポリゴンから親ポリゴンの形状を計算
   * @param {string} parentId - 親ポリゴンのID
   * @param {Polygon[]} allPolygons - すべてのポリゴンの配列
   * @param {Vertex[]} allVertices - すべての頂点の配列
   * @returns {Object} 計算された形状 { vertexIds, subPolygons, isMultiPolygon }
   */
  calculateParentShape(parentId, allPolygons, allVertices) {
    // 親IDを持つすべての子ポリゴンを取得
    const childPolygons = allPolygons.filter(p => p.parentId === parentId);
    if (childPolygons.length === 0) {
      return null;
    }
    
    // 子ポリゴンが1つの場合は単純にその形状を使用
    if (childPolygons.length === 1) {
      const child = childPolygons[0];
      return {
        vertexIds: child.vertexIds,
        subPolygons: child.subPolygons,
        isMultiPolygon: child.isMultiPolygon
      };
    }
    
    // 複数の子ポリゴンがある場合はMultiPolygonとして扱う
    const subPolygons = childPolygons.map(child => {
      if (child.isMultiPolygon) {
        // 子自体がMultiPolygonの場合はサブポリゴンを展開
        return child.subPolygons;
      } else {
        // 単一ポリゴンの場合は変換
        return {
          vertexIds: child.vertexIds,
          holesVertexIds: child.holesVertexIds
        };
      }
    }).flat();
    
    return {
      vertexIds: null, // 直接の頂点定義はなし
      subPolygons: subPolygons,
      isMultiPolygon: true
    };
  }

  /**
   * ポリゴンが特定のレイヤーに属する別のポリゴンに含まれているかチェック
   * @param {Polygon} polygon - チェックするポリゴン
   * @param {Polygon[]} allPolygons - すべてのポリゴンの配列
   * @param {Vertex[]} allVertices - すべての頂点の配列
   * @param {Layer[]} layers - すべてのレイヤーの配列
   * @param {GeometryService} geometryService - 幾何学サービス
   * @returns {boolean} 含まれていればtrue
   */
  isContainedInHigherLayerPolygon(polygon, allPolygons, allVertices, layers, geometryService) {
    // ポリゴンのレイヤーを特定
    const polygonLayer = layers.find(layer => layer.id === polygon.layerId);
    
    // 上位レイヤーをすべて特定
    const higherLayers = layers.filter(layer => layer.order < polygonLayer.order);
    
    // 上位レイヤーのポリゴンを検索
    const higherPolygons = allPolygons.filter(p => 
      higherLayers.some(layer => layer.id === p.layerId)
    );
    
    // ポリゴンの頂点座標を取得
    const polygonVertices = polygon.vertexIds.map(id => 
      allVertices.find(v => v.id === id)
    ).map(v => new Coordinate(v.x, v.y));
    
    // 各上位ポリゴンについて含有関係をチェック
    for (const higherPolygon of higherPolygons) {
      const higherVertices = higherPolygon.vertexIds.map(id => 
        allVertices.find(v => v.id === id)
      ).map(v => new Coordinate(v.x, v.y));
      
      // すべての頂点が上位ポリゴン内に含まれるかチェック
      const isContained = polygonVertices.every(vertex => 
        geometryService.isPointInPolygon(vertex, higherVertices)
      );
      
      if (isContained) {
        return true;
      }
    }
    
    return false;
  }

  /**
   * 子ポリゴンのリストを取得
   * @param {string} parentId - 親ポリゴンのID
   * @param {Polygon[]} allPolygons - すべてのポリゴンの配列
   * @returns {Polygon[]} 子ポリゴンの配列
   */
  getChildPolygons(parentId, allPolygons) {
    return allPolygons.filter(p => p.parentId === parentId);
  }

  /**
   * レイヤー内での領域の排他性をチェック
   * @param {Polygon} polygon - チェックするポリゴン
   * @param {Polygon[]} layerPolygons - 同じレイヤーの他のポリゴン
   * @param {Vertex[]} allVertices - すべての頂点の配列
   * @param {GeometryService} geometryService - 幾何学サービス
   * @returns {boolean} 排他的であればtrue（重なりがなければtrue）
   */
  checkExclusivity(polygon, layerPolygons, allVertices, geometryService) {
    // ポリゴンの頂点座標を取得
    const polygonVertices = polygon.vertexIds.map(id => 
      allVertices.find(v => v.id === id)
    ).map(v => new Coordinate(v.x, v.y));
    
    // 各レイヤーポリゴンについて重なりをチェック
    for (const layerPolygon of layerPolygons) {
      if (layerPolygon.id === polygon.id) continue; // 自分自身はスキップ
      
      const layerVertices = layerPolygon.vertexIds.map(id => 
        allVertices.find(v => v.id === id)
      ).map(v => new Coordinate(v.x, v.y));
      
      // ポリゴン同士の重なりをチェック
      if (geometryService.doPolygonsOverlap(polygonVertices, layerVertices)) {
        return false;
      }
    }
    
    return true;
  }

// src/application/WorldRepository.js
/**
 * 世界データのリポジトリインターフェース
 */
export class WorldRepository {
  /**
   * 世界データの読み込み
   * @returns {Promise<Object>} 世界データ
   */
  async getWorld() {
    throw new Error('Method not implemented');
  }

  /**
   * 世界データの保存
   * @param {Object} world - 保存する世界データ
   * @returns {Promise<void>}
   */
  async saveWorld(world) {
    throw new Error('Method not implemented');
  }
}

// src/application/usecases/EditFeatureUseCase.js
import { Feature } from '../../domain/entities/Feature';
import { Point } from '../../domain/entities/Point';
import { Line } from '../../domain/entities/Line';
import { Polygon } from '../../domain/entities/Polygon';

/**
 * 地理オブジェクトの編集を処理するユースケース
 */
export class EditFeatureUseCase {
  /**
   * ユースケースを作成
   * @param {WorldRepository} worldRepository - 世界データリポジトリ
   * @param {GeometryService} geometryService - 幾何学サービス
   * @param {LayerService} layerService - レイヤーサービス
   */
  constructor(worldRepository, geometryService, layerService) {
    this._worldRepository = worldRepository;
    this._geometryService = geometryService;
    this._layerService = layerService;
  }

  /**
   * 新しい地理オブジェクトを追加
   * @param {string} featureType - オブジェクトタイプ ('point', 'line', 'polygon')
   * @param {Object} properties - プロパティ情報
   * @param {Object} geometry - 形状情報
   * @param {string} layerId - レイヤーID
   * @returns {Promise<Feature>} 追加されたオブジェクト
   */
  async addFeature(featureType, properties, geometry, layerId) {
    const world = await this._worldRepository.getWorld();
    
    // IDの生成
    const featureId = this._generateId(featureType);
    
    // 形状情報の検証とID割り当て
    const processedGeometry = this._processGeometry(geometry, world);
    
    // 適切なファクトリーメソッドを使用して特徴オブジェクトを作成
    let feature;
    switch (featureType) {
      case 'point':
        feature = Point.create(featureId, properties, processedGeometry, layerId);
        break;
      case 'line':
        feature = Line.create(featureId, properties, processedGeometry, layerId);
        break;
      case 'polygon':
        // ポリゴンの場合、レイヤー内での排他性と階層関係の検証
        this._validatePolygonAddition(processedGeometry, layerId, world);
        feature = Polygon.create(featureId, properties, processedGeometry, layerId);
        break;
      default:
        throw new Error(`Unknown feature type: ${featureType}`);
    }
    
    // オブジェクトを追加
    world.features.push(feature);
    
    // 世界データを保存
    await this._worldRepository.saveWorld(world);
    
    return feature;
  }

  /**
   * 既存の地理オブジェクトを更新
   * @param {string} featureId - 更新するオブジェクトのID
   * @param {Object} updates - 更新内容
   * @returns {Promise<Feature>} 更新されたオブジェクト
   */
  async updateFeature(featureId, updates) {
    const world = await this._worldRepository.getWorld();
    
    // オブジェクトを検索
    const featureIndex = world.features.findIndex(f => f.id === featureId);
    if (featureIndex === -1) {
      throw new Error(`Feature not found with ID: ${featureId}`);
    }
    
    let feature = world.features[featureIndex];
    
    // 更新内容に応じてオブジェクトを変更
    if (updates.properties) {
      feature = feature.withProperties(updates.properties);
    }
    
    if (updates.geometry) {
      const processedGeometry = this._processGeometry(updates.geometry, world);
      
      // オブジェクトタイプごとの検証と処理
      if (feature instanceof Polygon) {
        this._validatePolygonUpdate(processedGeometry, feature, world);
        
        // 頂点IDsの更新
        if (processedGeometry.vertexIds) {
          feature = feature.withVertexIds(processedGeometry.vertexIds);
        }
        
        // 穴の更新
        if (processedGeometry.holesVertexIds) {
          feature = feature.withHolesVertexIds(processedGeometry.holesVertexIds);
        }
        
        // 親IDの更新
        if (processedGeometry.parentId) {
          feature = feature.withParentId(processedGeometry.parentId);
        }
        
        // 飛び地情報の更新
        if (processedGeometry.isMultiPolygon !== undefined) {
          feature = feature.withMultiPolygonData(
            processedGeometry.isMultiPolygon,
            processedGeometry.subPolygons || []
          );
        }
      } else {
        // 点または線の頂点IDsの更新
        if (processedGeometry.vertexIds) {
          feature = feature.withVertexIds(processedGeometry.vertexIds);
        } else if (processedGeometry.vertexId) {
          feature = feature.withVertexIds([processedGeometry.vertexId]);
        }
      }
    }
    
    if (updates.layerId) {
      feature = feature.withLayerId(updates.layerId);
    }
    
    // 更新されたオブジェクトを置き換え
    world.features[featureIndex] = feature;
    
    // 世界データを保存
    await this._worldRepository.saveWorld(world);
    
    return feature;
  }

  /**
   * 地理オブジェクトを削除
   * @param {string} featureId - 削除するオブジェクトのID
   * @returns {Promise<void>}
   */
  async deleteFeature(featureId) {
    const world = await this._worldRepository.getWorld();
    
    // オブジェクトを検索
    const featureIndex = world.features.findIndex(f => f.id === featureId);
    if (featureIndex === -1) {
      throw new Error(`Feature not found with ID: ${featureId}`);
    }
    
    const feature = world.features[featureIndex];
    
    // ポリゴンの場合、依存関係をチェック
    if (feature instanceof Polygon) {
      // 下位領域がある場合は削除不可
      if (feature.hasChildren()) {
        throw new Error('Cannot delete a polygon that has child polygons');
      }
      
      // 親ポリゴンの子IDsリストから自身を削除
      if (feature.parentId !== "0") {
        const parentIndex = world.features.findIndex(f => f.id === feature.parentId);
        if (parentIndex !== -1) {
          const parent = world.features[parentIndex];
          const updatedParent = parent.removeChildId(featureId);
          world.features[parentIndex] = updatedParent;
        }
      }
    }
    
    // オブジェクトを削除
    world.features.splice(featureIndex, 1);
    
    // 使われなくなった頂点を削除（共有頂点でない場合）
    this._cleanupUnusedVertices(world, feature.vertexIds);
    
    // 世界データを保存
    await this._worldRepository.saveWorld(world);
  }

  /**
   * 頂点を移動
   * @param {string} vertexId - 移動する頂点のID
   * @param {Object} newPosition - 新しい位置 { x, y }
   * @returns {Promise<Object>} 更新情報 { vertex, affectedFeatures }
   */
  async moveVertex(vertexId, newPosition) {
    const world = await this._worldRepository.getWorld();
    
    // 頂点を検索
    const vertexIndex = world.vertices.findIndex(v => v.id === vertexId);
    if (vertexIndex === -1) {
      throw new Error(`Vertex not found with ID: ${vertexId}`);
    }
    
    const vertex = world.vertices[vertexIndex];
    
    // 新しい位置での衝突検出と処理
    const adjustedPosition = this._handleCollisionForVertexMove(
      vertex, newPosition, world
    );
    
    // 頂点を更新
    const updatedVertex = vertex.withCoordinates(
      adjustedPosition.x,
      adjustedPosition.y
    );
    world.vertices[vertexIndex] = updatedVertex;
    
    // この頂点を使用するすべての地理オブジェクトを特定
    const affectedFeatures = world.features.filter(f => 
      f.vertexIds.includes(vertexId)
    );
    
    // 世界データを保存
    await this._worldRepository.saveWorld(world);
    
    return { 
      vertex: updatedVertex, 
      affectedFeatures: affectedFeatures 
    };
  }

  /**
   * 頂点を共有化
   * @param {string} vertexId1 - 頂点1のID
   * @param {string} vertexId2 - 頂点2のID
   * @returns {Promise<Object>} 更新情報 { keptVertex, removedVertex, affectedFeatures }
   */
  async shareVertices(vertexId1, vertexId2) {
    const world = await this._worldRepository.getWorld();
    
    // 頂点を検索
    const vertex1 = world.vertices.find(v => v.id === vertexId1);
    const vertex2 = world.vertices.find(v => v.id === vertexId2);
    
    if (!vertex1 || !vertex2) {
      throw new Error('One or both vertices not found');
    }
    
    // 既に同じ位置にある場合は何もしない
    if (vertex1.x === vertex2.x && vertex1.y === vertex2.y) {
      return null;
    }
    
    // 古いほうのIDを持つ頂点を保持
    const keptVertexId = this._getOlderVertexId(vertexId1, vertexId2);
    const removedVertexId = keptVertexId === vertexId1 ? vertexId2 : vertexId1;
    
    const keptVertex = keptVertexId === vertexId1 ? vertex1 : vertex2;
    const removedVertex = keptVertexId === vertexId1 ? vertex2 : vertex1;
    
    // この頂点を使用するすべての地理オブジェクトを特定
    const affectedFeatures = [];
    
    // 削除される頂点を使用するすべてのオブジェクトについて頂点IDを置き換え
    for (let i = 0; i < world.features.length; i++) {
      const feature = world.features[i];
      
      if (feature.vertexIds.includes(removedVertexId)) {
        const newVertexIds = feature.vertexIds.map(id => 
          id === removedVertexId ? keptVertexId : id
        );
        
        const updatedFeature = feature.withVertexIds(newVertexIds);
        world.features[i] = updatedFeature;
        affectedFeatures.push(updatedFeature);
      }
      
      // ポリゴンの穴についても処理
      if (feature instanceof Polygon && feature.holesVertexIds.length > 0) {
        let holesUpdated = false;
        const newHolesVertexIds = feature.holesVertexIds.map(hole => {
          if (hole.includes(removedVertexId)) {
            holesUpdated = true;
            return hole.map(id => id === removedVertexId ? keptVertexId : id);
          }
          return hole;
        });
        
        if (holesUpdated) {
          const updatedFeature = feature.withHolesVertexIds(newHolesVertexIds);
          world.features[i] = updatedFeature;
          
          if (!affectedFeatures.some(f => f.id === updatedFeature.id)) {
            affectedFeatures.push(updatedFeature);
          }
        }
      }
    }
    
    // 削除される頂点を削除
    const removedVertexIndex = world.vertices.findIndex(v => v.id === removedVertexId);
    world.vertices.splice(removedVertexIndex, 1);
    
    // 世界データを保存
    await this._worldRepository.saveWorld(world);
    
    return {
      keptVertex,
      removedVertex,
      affectedFeatures
    };
  }

  /**
   * 共有頂点を解除
   * @param {string} vertexId - 共有を解除する頂点のID
   * @param {string} featureId - この特徴に対して新しい頂点を作成
   * @returns {Promise<Object>} 更新情報 { newVertex, updatedFeature }
   */
  async unlinkSharedVertex(vertexId, featureId) {
    const world = await this._worldRepository.getWorld();
    
    // 頂点を検索
    const vertex = world.vertices.find(v => v.id === vertexId);
    if (!vertex) {
      throw new Error(`Vertex not found with ID: ${vertexId}`);
    }
    
    // 特徴を検索
    const featureIndex = world.features.findIndex(f => f.id === featureId);
    if (featureIndex === -1) {
      throw new Error(`Feature not found with ID: ${featureId}`);
    }
    
    const feature = world.features[featureIndex];
    
    // 特徴が指定された頂点を使用しているか確認
    if (!feature.vertexIds.includes(vertexId)) {
      throw new Error(`Feature does not use vertex with ID: ${vertexId}`);
    }
    
    // 新しい頂点を作成
    const newVertexId = this._generateId('vertex');
    const newVertex = vertex.withCoordinates(vertex.x, vertex.y);
    Object.defineProperty(newVertex, '_id', { value: newVertexId });
    
    world.vertices.push(newVertex);
    
    // 特徴の頂点IDsを更新
    const newVertexIds = feature.vertexIds.map(id => 
      id === vertexId ? newVertexId : id
    );
    
    const updatedFeature = feature.withVertexIds(newVertexIds);
    world.features[featureIndex] = updatedFeature;
    
    // ポリゴンの穴についても処理
    if (feature instanceof Polygon && feature.holesVertexIds.length > 0) {
      const newHolesVertexIds = feature.holesVertexIds.map(hole => {
        if (hole.includes(vertexId)) {
          return hole.map(id => id === vertexId ? newVertexId : id);
        }
        return hole;
      });
      
      const updatedWithHoles = updatedFeature.withHolesVertexIds(newHolesVertexIds);
      world.features[featureIndex] = updatedWithHoles;
    }
    
    // 世界データを保存
    await this._worldRepository.saveWorld(world);
    
    return {
      newVertex,
      updatedFeature: world.features[featureIndex]
    };
  }

  /**
   * ポリゴンを分裂
   * @param {string} polygonId - 分裂するポリゴンのID
   * @param {Object} divisionData - 分裂情報
   * @returns {Promise<Object>} 更新情報 { originalPolygon, newPolygons }
   */
  async splitPolygon(polygonId, divisionData) {
    const world = await this._worldRepository.getWorld();
    
    // ポリゴンを検索
    const polygonIndex = world.features.findIndex(f => 
      f.id === polygonId && f instanceof Polygon
    );
    
    if (polygonIndex === -1) {
      throw new Error(`Polygon not found with ID: ${polygonId}`);
    }
    
    const polygon = world.features[polygonIndex];
    
    // 下位領域を持つポリゴンは分割不可
    if (polygon.hasChildren()) {
      throw new Error('Cannot split a polygon that has child polygons');
    }
    
    // 分割タイプに応じた処理
    const newPolygons = [];
    
    if (divisionData.type === 'bisect') {
      // 線による二分割
      const { line, properties } = divisionData;
      
      // 二分割アルゴリズムの実装
      // ...

      // 本来はここで二分割処理を実装するが、簡易的な処理として
      // 既存ポリゴンを元に2つの新しいポリゴンを作成する
      
      // 新しいポリゴン1
      const newPoly1Id = this._generateId('polygon');
      const newPoly1 = Polygon.create(
        newPoly1Id,
        [polygon.properties[0]], // 元のプロパティをコピー
        {
          vertexIds: [...polygon.vertexIds.slice(0, Math.ceil(polygon.vertexIds.length / 2))],
          holesVertexIds: [],
          parentId: polygon.parentId
        },
        polygon.layerId
      );
      
      // 新しいポリゴン2
      const newPoly2Id = this._generateId('polygon');
      const newPoly2 = Polygon.create(
        newPoly2Id,
        properties ? [properties] : [polygon.properties[0]], // 指定されたプロパティまたは元のプロパティ
        {
          vertexIds: [...polygon.vertexIds.slice(Math.floor(polygon.vertexIds.length / 2))],
          holesVertexIds: [],
          parentId: polygon.parentId
        },
        polygon.layerId
      );
      
      newPolygons.push(newPoly1, newPoly2);
      
    } else if (divisionData.type === 'hole') {
      // 穴による分割
      const { holeVertexIds, newPolygonProperties } = divisionData;
      
      // 穴のバリデーション
      this._validatePolygonHole(holeVertexIds, polygon, world);
      
      // 穴を追加した元のポリゴン
      const updatedHoles = [...polygon.holesVertexIds, holeVertexIds];
      const updatedPolygon = polygon.withHolesVertexIds(updatedHoles);
      
      // 穴から新しいポリゴンを作成
      const newPolyId = this._generateId('polygon');
      const newPoly = Polygon.create(
        newPolyId,
        newPolygonProperties ? [newPolygonProperties] : [polygon.properties[0]],
        {
          vertexIds: holeVertexIds,
          holesVertexIds: [],
          parentId: polygon.parentId
        },
        polygon.layerId
      );
      
      world.features[polygonIndex] = updatedPolygon;
      newPolygons.push(newPoly);
    }
    
    // 新しいポリゴンを追加
    for (const newPoly of newPolygons) {
      world.features.push(newPoly);
    }
    
    // 元のポリゴンを削除
    if (divisionData.type === 'bisect') {
      world.features.splice(polygonIndex, 1);
    }
    
    // 世界データを保存
    await this._worldRepository.saveWorld(world);
    
    return {
      originalPolygon: polygon,
      newPolygons: newPolygons
    };
  }

  /**
   * ポリゴンの所属変更
   * @param {string} polygonId - 所属を変更するポリゴンのID
   * @param {string} newParentId - 新しい親ポリゴンのID
   * @returns {Promise<Object>} 更新情報 { updatedPolygon, oldParent, newParent }
   */
  async changePolygonParent(polygonId, newParentId) {
    const world = await this._worldRepository.getWorld();
    
    // ポリゴンを検索
    const polygonIndex = world.features.findIndex(f => 
      f.id === polygonId && f instanceof Polygon
    );
    
    if (polygonIndex === -1) {
      throw new Error(`Polygon not found with ID: ${polygonId}`);
    }
    
    const polygon = world.features[polygonIndex];
    
    // 下位領域を持つポリゴンは所属変更不可
    if (polygon.hasChildren()) {
      throw new Error('Cannot change parent of a polygon that has child polygons');
    }
    
    // 新しい親を検索
    let newParent = null;
    if (newParentId !== "0") {
      const newParentIndex = world.features.findIndex(f => 
        f.id === newParentId && f instanceof Polygon
      );
      
      if (newParentIndex === -1) {
        throw new Error(`Parent polygon not found with ID: ${newParentId}`);
      }
      
      newParent = world.features[newParentIndex];
      
      // レイヤーの階層関係を検証
      const polygonLayer = world.layers.find(l => l.id === polygon.layerId);
      const parentLayer = world.layers.find(l => l.id === newParent.layerId);
      
      if (parentLayer.order >= polygonLayer.order) {
        throw new Error('Parent polygon must be in a higher layer');
      }
    }
    
    // 古い親から子IDを削除
    let oldParent = null;
    if (polygon.parentId !== "0") {
      const oldParentIndex = world.features.findIndex(f => 
        f.id === polygon.parentId && f instanceof Polygon
      );
      
      if (oldParentIndex !== -1) {
        oldParent = world.features[oldParentIndex];
        const updatedOldParent = oldParent.removeChildId(polygonId);
        world.features[oldParentIndex] = updatedOldParent;
      }
    }
    
    // ポリゴンの親IDを更新
    const updatedPolygon = polygon.withParentId(newParentId);
    world.features[polygonIndex] = updatedPolygon;
    
    // 新しい親に子IDを追加
    if (newParent) {
      const newParentIndex = world.features.findIndex(f => f.id === newParentId);
      const updatedNewParent = newParent.addChildId(polygonId);
      world.features[newParentIndex] = updatedNewParent;
    }
    
    // 世界データを保存
    await this._worldRepository.saveWorld(world);
    
    return {
      updatedPolygon,
      oldParent,
      newParent
    };
  }

  /**
   * ID生成
   * @param {string} type - 生成するIDのタイプ
   * @returns {string} 生成されたID
   * @private
   */
  _generateId(type) {
    const timestamp = new Date().getTime();
    const random = Math.floor(Math.random() * 10000);
    return `${type}-${timestamp}-${random}`;
  }

  /**
   * 形状情報の処理とID割り当て
   * @param {Object} geometry - 形状情報
   * @param {Object} world - 世界データ
   * @returns {Object} 処理された形状情報
   * @private
   */
  _processGeometry(geometry, world) {
    // 既存頂点のコピー
    const processedGeometry = { ...geometry };
    
    // 新しい頂点の場合はIDを割り当てて頂点リストに追加
    if (geometry.vertices) {
      processedGeometry.vertexIds = [];
      
      for (const vertex of geometry.vertices) {
        const vertexId = this._generateId('vertex');
        processedGeometry.vertexIds.push(vertexId);
        
        // 新しい頂点をワールドに追加
        world.vertices.push({
          id: vertexId,
          x: vertex.x,
          y: vertex.y
        });
      }
    }
    
    // 穴についても同様の処理
    if (geometry.holes) {
      processedGeometry.holesVertexIds = [];
      
      for (const hole of geometry.holes) {
        const holeIds = [];
        for (const vertex of hole) {
          const vertexId = this._generateId('vertex');
          holeIds.push(vertexId);
          
          world.vertices.push({
            id: vertexId,
            x: vertex.x,
            y: vertex.y
          });
        }
        processedGeometry.holesVertexIds.push(holeIds);
      }
    }
    
    return processedGeometry;
  }

  /**
   * ポリゴンの追加検証
   * @param {Object} geometry - 形状情報
   * @param {string} layerId - レイヤーID
   * @param {Object} world - 世界データ
   * @private
   */
  _validatePolygonAddition(geometry, layerId, world) {
    // 同一レイヤー内のポリゴンとの排他性チェック
    // ...
    
    // 親ポリゴンとの関係チェック
    // ...
  }

  /**
   * ポリゴンの更新検証
   * @param {Object} geometry - 形状情報
   * @param {Polygon} polygon - 更新するポリゴン
   * @param {Object} world - 世界データ
   * @private
   */
  _validatePolygonUpdate(geometry, polygon, world) {
    // 同一レイヤー内のポリゴンとの排他性チェック
    // ...
    
    // 親ポリゴンとの関係チェック
    // ...
    
    // 子ポリゴンとの関係チェック
    // ...
  }

  /**
   * ポリゴンの穴のバリデーション
   * @param {string[]} holeVertexIds - 穴の頂点IDの配列
   * @param {Polygon} polygon - ポリゴン
   * @param {Object} world - 世界データ
   * @private
   */
  _validatePolygonHole(holeVertexIds, polygon, world) {
    // 穴が少なくとも3つの頂点を持つことを確認
    if (holeVertexIds.length < 3) {
      throw new Error('Polygon hole must have at least three vertices');
    }
    
    // 穴がポリゴン内部に完全に含まれることを確認
    // ...
    
    // 穴が他の穴と交差しないことを確認
    // ...
  }

  /**
   * 頂点移動時の衝突処理
   * @param {Vertex} vertex - 移動する頂点
   * @param {Object} newPosition - 新しい位置 { x, y }
   * @param {Object} world - 世界データ
   * @returns {Object} 調整された位置 { x, y }
   * @private
   */
  _handleCollisionForVertexMove(vertex, newPosition, world) {
    // この頂点を使用するポリゴンを特定
    const polygons = world.features.filter(f => 
      f instanceof Polygon && f.vertexIds.includes(vertex.id)
    );
    
    if (polygons.length === 0) {
      // ポリゴンに属さない頂点は自由に移動可能
      return newPosition;
    }
    
    // 各ポリゴンについて衝突判定
    // ...
    
    // 本来ならここで衝突判定とエッジ滑り処理を実装するが、簡易的な処理として
    // 新しい位置をそのまま返す
    return newPosition;
  }

  /**
   * 使用されていない頂点のクリーンアップ
   * @param {Object} world - 世界データ
   * @param {string[]} vertexIds - チェックする頂点IDの配列
   * @private
   */
  _cleanupUnusedVertices(world, vertexIds) {
    for (const vertexId of vertexIds) {
      // この頂点を使用する他のオブジェクトがあるかチェック
      const isUsed = world.features.some(f => 
        f.vertexIds.includes(vertexId)
      );
      
      if (!isUsed) {
        // 使用されていない頂点を削除
        const vertexIndex = world.vertices.findIndex(v => v.id === vertexId);
        if (vertexIndex !== -1) {
          world.vertices.splice(vertexIndex, 1);
        }
      }
    }
  }

  /**
   * 古いほうのIDを持つ頂点を特定
   * @param {string} id1 - 頂点1のID
   * @param {string} id2 - 頂点2のID
   * @returns {string} 古いほうのID
   * @private
   */
  _getOlderVertexId(id1, id2) {
    // IDからタイムスタンプ部分を抽出して比較
    const getTimestamp = (id) => {
      const parts = id.split('-');
      return parts.length > 1 ? parseInt(parts[1], 10) : 0;
    };
    
    const timestamp1 = getTimestamp(id1);
    const timestamp2 = getTimestamp(id2);
    
    return timestamp1 <= timestamp2 ? id1 : id2;
  }
}

// src/application/usecases/NavigateTimeUseCase.js
import { TimePoint } from '../../domain/value-objects/TimePoint';

/**
 * 時間移動を処理するユースケース
 */
export class NavigateTimeUseCase {
  /**
   * ユースケースを作成
   * @param {TimeService} timeService - 時間サービス
   */
  constructor(timeService) {
    this._timeService = timeService;
    this._currentTime = new TimePoint(0); // デフォルト値
  }

  /**
   * 現在の時間点を取得
   * @returns {TimePoint} 現在の時間点
   */
  getCurrentTime() {
    return this._currentTime;
  }

  /**
   * 特定の時間点に移動
   * @param {number} year - 年
   * @param {number} [month] - 月（オプション）
   * @param {number} [day] - 日（オプション）
   * @returns {TimePoint} 設定された時間点
   */
  moveToTime(year, month = null, day = null) {
    this._currentTime = new TimePoint(year, month, day);
    return this._currentTime;
  }

  /**
   * 指定した日数だけ前進
   * @param {number} days - 進める日数
   * @returns {TimePoint} 進んだ後の時間点
   */
  advanceTime(days) {
    this._currentTime = this._timeService.advanceDays(this._currentTime, days);
    return this._currentTime;
  }

  /**
   * 指定した日数だけ後退
   * @param {number} days - 戻る日数
   * @returns {TimePoint} 戻った後の時間点
   */
  retreatTime(days) {
    return this.advanceTime(-days);
  }

  /**
   * 時間間隔を考慮して次の「意味のある」時点に進む
   * @param {Feature[]} features - 地理オブジェクトの配列
   * @returns {TimePoint} 次の意味のある時間点
   */
  moveToNextSignificantTime(features) {
    const current = this._currentTime;
    let nextTime = null;
    
    // すべての特徴のプロパティを検索して現在より未来の最も近い時間点を見つける
    for (const feature of features) {
      for (const prop of feature.properties) {
        if (prop.timePoint.isBefore(current)) {
          continue; // 過去の時間点はスキップ
        }
        
        if (prop.timePoint.equals(current)) {
          continue; // 現在と同じ時間点はスキップ
        }
        
        if (nextTime === null || prop.timePoint.isBefore(nextTime)) {
          nextTime = prop.timePoint;
        }
      }
    }
    
    if (nextTime) {
      this._currentTime = nextTime;
    }
    
    return this._currentTime;
  }

  /**
   * 時間間隔を考慮して前の「意味のある」時点に戻る
   * @param {Feature[]} features - 地理オブジェクトの配列
   * @returns {TimePoint} 前の意味のある時間点
   */
  moveToPreviousSignificantTime(features) {
    const current = this._currentTime;
    let prevTime = null;
    
    // すべての特徴のプロパティを検索して現在より過去の最も近い時間点を見つける
    for (const feature of features) {
      for (const prop of feature.properties) {
        if (current.isBefore(prop.timePoint)) {
          continue; // 未来の時間点はスキップ
        }
        
        if (prop.timePoint.equals(current)) {
          continue; // 現在と同じ時間点はスキップ
        }
        
        if (prevTime === null || prevTime.isBefore(prop.timePoint)) {
          prevTime = prop.timePoint;
        }
      }
    }
    
    if (prevTime) {
      this._currentTime = prevTime;
    }
    
    return this._currentTime;
  }
}

// src/application/usecases/ManageLayersUseCase.js
import { Layer } from '../../domain/entities/Layer';

/**
 * レイヤー管理を処理するユースケース
 */
export class ManageLayersUseCase {
  /**
   * ユースケースを作成
   * @param {WorldRepository} worldRepository - 世界データリポジトリ
   * @param {LayerService} layerService - レイヤーサービス
   */
  constructor(worldRepository, layerService) {
    this._worldRepository = worldRepository;
    this._layerService = layerService;
  }

  /**
   * すべてのレイヤーを取得
   * @returns {Promise<Layer[]>} レイヤーの配列
   */
  async getLayers() {
    const world = await this._worldRepository.getWorld();
    return world.layers;
  }

  /**
   * レイヤーを追加
   * @param {string} name - レイヤー名
   * @param {string} [description=""] - 説明
   * @returns {Promise<Layer>} 追加されたレイヤー
   */
  async addLayer(name, description = "") {
    const world = await this._worldRepository.getWorld();
    
    // 次のレイヤー順序を決定
    const nextOrder = world.layers.length > 0 
      ? Math.max(...world.layers.map(l => l.order)) + 1
      : 0;
    
    // 新しいレイヤーを作成
    const layerId = `layer-${new Date().getTime()}`;
    const newLayer = new Layer(layerId, name, nextOrder, true, 1.0, description);
    
    // 世界データに追加
    world.layers.push(newLayer);
    
    // レイヤー階層を検証
    const isValid = this._layerService.validateLayerHierarchy(world.layers);
    if (!isValid) {
      throw new Error('Layer hierarchy validation failed');
    }
    
    // 世界データを保存
    await this._worldRepository.saveWorld(world);
    
    return newLayer;
  }

  /**
   * レイヤーを更新
   * @param {string} layerId - 更新するレイヤーのID
   * @param {Object} updates - 更新内容
   * @returns {Promise<Layer>} 更新されたレイヤー
   */
  async updateLayer(layerId, updates) {
    const world = await this._worldRepository.getWorld();
    
    // レイヤーを検索
    const layerIndex = world.layers.findIndex(l => l.id === layerId);
    if (layerIndex === -1) {
      throw new Error(`Layer not found with ID: ${layerId}`);
    }
    
    let layer = world.layers[layerIndex];
    
    // 更新内容に応じてレイヤーを変更
    if (updates.name !== undefined) {
      layer = layer.withName(updates.name);
    }
    
    if (updates.visible !== undefined) {
      layer = layer.withVisibility(updates.visible);
    }
    
    if (updates.opacity !== undefined) {
      layer = layer.withOpacity(updates.opacity);
    }
    
    if (updates.description !== undefined) {
      layer = layer.withDescription(updates.description);
    }
    
    // 更新されたレイヤーを置き換え
    world.layers[layerIndex] = layer;
    
    // 世界データを保存
    await this._worldRepository.saveWorld(world);
    
    return layer;
  }

  /**
   * レイヤーを削除
   * @param {string} layerId - 削除するレイヤーのID
   * @returns {Promise<void>}
   */
  async deleteLayer(layerId) {
    const world = await this._worldRepository.getWorld();
    
    // レイヤーを検索
    const layerIndex = world.layers.findIndex(l => l.id === layerId);
    if (layerIndex === -1) {
      throw new Error(`Layer not found with ID: ${layerId}`);
    }
    
    const layer = world.layers[layerIndex];
    
    // このレイヤーに関連するオブジェクトがあるか確認
    const hasRelatedFeatures = world.features.some(f => f.layerId === layerId);
    if (hasRelatedFeatures) {
      throw new Error('Cannot delete a layer that has related features');
    }
    
    // レイヤーを削除
    world.layers.splice(layerIndex, 1);
    
    // レイヤー順序を再整理
    world.layers.sort((a, b) => a.order - b.order);
    
    for (let i = 0; i < world.layers.length; i++) {
      if (world.layers[i].order !== i) {
        const updatedLayer = world.layers[i].withOrder(i);
        world.layers[i] = updatedLayer;
      }
    }
    
    // 世界データを保存
    await this._worldRepository.saveWorld(world);
  }

  /**
   * レイヤーの順序を変更
   * @param {string} layerId - 移動するレイヤーのID
   * @param {number} newOrder - 新しい順序
   * @returns {Promise<Layer[]>} 更新されたレイヤーの配列
   */
  async reorderLayer(layerId, newOrder) {
    const world = await this._worldRepository.getWorld();
    
    // レイヤーを検索
    const layerIndex = world.layers.findIndex(l => l.id === layerId);
    if (layerIndex === -1) {
      throw new Error(`Layer not found with ID: ${layerId}`);
    }
    
    const layer = world.layers[layerIndex];
    const oldOrder = layer.order;
    
    // 有効範囲内の順序に調整
    newOrder = Math.max(0, Math.min(world.layers.length - 1, newOrder));
    
    // 順序が変わらない場合は何もしない
    if (oldOrder === newOrder) {
      return world.layers;
    }
    
    // レイヤーの順序を更新
    // 注意: 実際の実装では、レイヤーの階層変更によって、
    // 関連するポリゴンの親子関係を再検証する必要があります。
    
    // 一旦レイヤーを取り除く
    world.layers.splice(layerIndex, 1);
    
    // 新しい順序で再配置
    let updatedLayers = [...world.layers];
    updatedLayers.splice(newOrder, 0, layer);
    
    // 順序を再設定
    updatedLayers = updatedLayers.map((l, index) => {
      if (l.order !== index) {
        const updatedLayer = new Layer(
          l.id, l.name, index, l.visible, l.opacity, l.description
        );
        return updatedLayer;
      }
      return l;
    });
    
    // 更新されたレイヤーで置き換え
    world.layers = updatedLayers;
    
    // レイヤー階層を検証
    const isValid = this._layerService.validateLayerHierarchy(world.layers);
    if (!isValid) {
      throw new Error('Layer hierarchy validation failed');
    }
    
    // 世界データを保存
    await this._worldRepository.saveWorld(world);
    
    return world.layers;
  }
}

// src/infrastructure/persistence/FileSystem.js

/**
 * ファイルシステム操作の抽象化
 */
export class FileSystem {
  /**
   * ファイルを読み込む
   * @param {string} filePath - ファイルパス
   * @returns {Promise<string>} ファイル内容
   */
  async readFile(filePath) {
    try {
      // Electronの場合
      if (window.electron && window.electron.fs) {
        return await window.electron.fs.readFile(filePath, 'utf8');
      }
      
      // ブラウザでのテスト用ローカルストレージ
      if (typeof localStorage !== 'undefined') {
        const content = localStorage.getItem(filePath);
        if (content) {
          return content;
        }
      }
      
      throw new Error('File system not available');
    } catch (error) {
      throw new Error(`Failed to read file: ${error.message}`);
    }
  }

  /**
   * ファイルを書き込む
   * @param {string} filePath - ファイルパス
   * @param {string} content - 書き込む内容
   * @returns {Promise<void>}
   */
  async writeFile(filePath, content) {
    try {
      // Electronの場合
      if (window.electron && window.electron.fs) {
        await window.electron.fs.writeFile(filePath, content, 'utf8');
        return;
      }
      
      // ブラウザでのテスト用ローカルストレージ
      if (typeof localStorage !== 'undefined') {
        localStorage.setItem(filePath, content);
        return;
      }
      
      throw new Error('File system not available');
    } catch (error) {
      throw new Error(`Failed to write file: ${error.message}`);
    }
  }

  /**
   * ファイルが存在するか確認
   * @param {string} filePath - ファイルパス
   * @returns {Promise<boolean>} 存在すればtrue
   */
  async fileExists(filePath) {
    try {
      // Electronの場合
      if (window.electron && window.electron.fs) {
        return await window.electron.fs.exists(filePath);
      }
      
      // ブラウザでのテスト用ローカルストレージ
      if (typeof localStorage !== 'undefined') {
        return localStorage.getItem(filePath) !== null;
      }
      
      return false;
    } catch (error) {
      return false;
    }
  }

  /**
   * ディレクトリを作成
   * @param {string} dirPath - ディレクトリパス
   * @returns {Promise<void>}
   */
  async makeDirectory(dirPath) {
    try {
      // Electronの場合
      if (window.electron && window.electron.fs) {
        await window.electron.fs.mkdir(dirPath, { recursive: true });
      }
      // ブラウザでは何もしない
    } catch (error) {
      throw new Error(`Failed to create directory: ${error.message}`);
    }
  }

  /**
   * バックアップを作成
   * @param {string} filePath - 元ファイルパス
   * @returns {Promise<string>} バックアップファイルパス
   */
  async createBackup(filePath) {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupPath = `${filePath}.${timestamp}.bak`;
    
    try {
      const content = await this.readFile(filePath);
      await this.writeFile(backupPath, content);
      return backupPath;
    } catch (error) {
      throw new Error(`Failed to create backup: ${error.message}`);
    }
  }
}

// src/infrastructure/persistence/JSONSerializer.js
import { Vertex } from '../../domain/entities/Vertex';
import { Point } from '../../domain/entities/Point';
import { Line } from '../../domain/entities/Line';
import { Polygon } from '../../domain/entities/Polygon';
import { Layer } from '../../domain/entities/Layer';
import { TimePoint } from '../../domain/value-objects/TimePoint';
import { Property } from '../../domain/value-objects/Property';

/**
 * JSON形式でのデータシリアライズ/デシリアライズ
 */
export class JSONSerializer {
  /**
   * ドメインオブジェクトをJSONにシリアライズ
   * @param {Object} world - 世界データ
   * @returns {string} JSONデータ
   */
  serialize(world) {
    const data = {
      version: "1.0",
      layers: world.layers.map(layer => this._serializeLayer(layer)),
      vertices: world.vertices.map(vertex => this._serializeVertex(vertex)),
      points: [],
      lines: [],
      polygons: [],
      metadata: world.metadata || {}
    };
    
    // 地理オブジェクトを種類別に分類
    for (const feature of world.features) {
      if (feature instanceof Point) {
        data.points.push(this._serializePoint(feature));
      } else if (feature instanceof Line) {
        data.lines.push(this._serializeLine(feature));
      } else if (feature instanceof Polygon) {
        data.polygons.push(this._serializePolygon(feature));
      }
    }
    
    return JSON.stringify(data, null, 2);
  }

  /**
   * JSONからドメインオブジェクトをデシリアライズ
   * @param {string} json - JSONデータ
   * @returns {Object} 世界データ
   */
  deserialize(json) {
    const data = JSON.parse(json);
    
    // バージョンチェック
    if (!data.version || data.version !== "1.0") {
      console.warn(`Warning: Unknown data version ${data.version}`);
    }
    
    const world = {
      // レイヤーの復元
      layers: (data.layers || []).map(layer => this._deserializeLayer(layer)),
      
      // 頂点の復元
      vertices: (data.vertices || []).map(vertex => this._deserializeVertex(vertex)),
      
      // 特徴の復元（空の配列で初期化）
      features: [],
      
      // メタデータの復元
      metadata: data.metadata || {}
    };
    
    // 点情報の復元
    if (data.points) {
      for (const pointData of data.points) {
        world.features.push(this._deserializePoint(pointData));
      }
    }
    
    // 線情報の復元
    if (data.lines) {
      for (const lineData of data.lines) {
        world.features.push(this._deserializeLine(lineData));
      }
    }
    
    // 面情報の復元
    if (data.polygons) {
      for (const polygonData of data.polygons) {
        world.features.push(this._deserializePolygon(polygonData));
      }
    }
    
    return world;
  }

  // 以下、個別のシリアライズ/デシリアライズメソッド

  /**
   * 頂点をシリアライズ
   * @param {Vertex} vertex - 頂点
   * @returns {Object} シリアライズされた頂点
   * @private
   */
  _serializeVertex(vertex) {
    return {
      id: vertex.id,
      x: vertex.x,
      y: vertex.y
    };
  }

  /**
   * 頂点をデシリアライズ
   * @param {Object} data - シリアライズされた頂点
   * @returns {Vertex} 頂点
   * @private
   */
  _deserializeVertex(data) {
    return new Vertex(data.id, data.x, data.y);
  }

  /**
   * 時間点をシリアライズ
   * @param {TimePoint} timePoint - 時間点
   * @returns {Object} シリアライズされた時間点
   * @private
   */
  _serializeTimePoint(timePoint) {
    const result = {
      year: timePoint.year
    };
    
    if (timePoint.month !== null) {
      result.month = timePoint.month;
    }
    
    if (timePoint.day !== null) {
      result.day = timePoint.day;
    }
    
    return result;
  }

  /**
   * 時間点をデシリアライズ
   * @param {Object} data - シリアライズされた時間点
   * @returns {TimePoint} 時間点
   * @private
   */
  _deserializeTimePoint(data) {
    return new TimePoint(
      data.year,
      data.month !== undefined ? data.month : null,
      data.day !== undefined ? data.day : null
    );
  }

  /**
   * プロパティをシリアライズ
   * @param {Property} property - プロパティ
   * @returns {Object} シリアライズされたプロパティ
   * @private
   */
  _serializeProperty(property) {
    const result = {
      timePoint: this._serializeTimePoint(property.timePoint),
      name: property.name,
      description: property.description,
      ...property.getAttributes()
    };
    
    if (property.startTime) {
      result.timeRange = {
        start: this._serializeTimePoint(property.startTime)
      };
      
      if (property.endTime) {
        result.timeRange.end = this._serializeTimePoint(property.endTime);
      }
    } else if (property.endTime) {
      result.timeRange = {
        end: this._serializeTimePoint(property.endTime)
      };
    }
    
    return result;
  }

  /**
   * プロパティをデシリアライズ
   * @param {Object} data - シリアライズされたプロパティ
   * @returns {Property} プロパティ
   * @private
   */
  _deserializeProperty(data) {
    const timePoint = this._deserializeTimePoint(data.timePoint);
    
    // 基本属性と追加属性を分離
    const { timePoint: tp, timeRange, name, description, ...attributes } = data;
    
    // 時間範囲の処理
    let startTime = null;
    let endTime = null;
    
    if (timeRange) {
      if (timeRange.start) {
        startTime = this._deserializeTimePoint(timeRange.start);
      }
      
      if (timeRange.end) {
        endTime = this._deserializeTimePoint(timeRange.end);
      }
    }
    
    return new Property(
      timePoint,
      name,
      description,
      attributes,
      startTime,
      endTime
    );
  }

  /**
   * レイヤーをシリアライズ
   * @param {Layer} layer - レイヤー
   * @returns {Object} シリアライズされたレイヤー
   * @private
   */
  _serializeLayer(layer) {
    return {
      id: layer.id,
      name: layer.name,
      order: layer.order,
      visible: layer.visible,
      opacity: layer.opacity,
      description: layer.description
    };
  }

  /**
   * レイヤーをデシリアライズ
   * @param {Object} data - シリアライズされたレイヤー
   * @returns {Layer} レイヤー
   * @private
   */
  _deserializeLayer(data) {
    return new Layer(
      data.id,
      data.name,
      data.order,
      data.visible,
      data.opacity,
      data.description || ""
    );
  }

  /**
   * 点情報をシリアライズ
   * @param {Point} point - 点情報
   * @returns {Object} シリアライズされた点情報
   * @private
   */
  _serializePoint(point) {
    return {
      id: point.id,
      vertexIds: [...point.vertexIds],
      properties: point.properties.map(prop => this._serializeProperty(prop)),
      layerId: point.layerId
    };
  }

  /**
   * 点情報をデシリアライズ
   * @param {Object} data - シリアライズされた点情報
   * @returns {Point} 点情報
   * @private
   */
  _deserializePoint(data) {
    return new Point(
      data.id,
      data.vertexIds,
      data.properties.map(prop => this._deserializeProperty(prop)),
      data.layerId
    );
  }

  /**
   * 線情報をシリアライズ
   * @param {Line} line - 線情報
   * @returns {Object} シリアライズされた線情報
   * @private
   */
  _serializeLine(line) {
    return {
      id: line.id,
      vertexIds: [...line.vertexIds],
      properties: line.properties.map(prop => this._serializeProperty(prop)),
      layerId: line.layerId
    };
  }

  /**
   * 線情報をデシリアライズ
   * @param {Object} data - シリアライズされた線情報
   * @returns {Line} 線情報
   * @private
   */
  _deserializeLine(data) {
    return new Line(
      data.id,
      data.vertexIds,
      data.properties.map(prop => this._deserializeProperty(prop)),
      data.layerId
    );
  }

  /**
   * 面情報をシリアライズ
   * @param {Polygon} polygon - 面情報
   * @returns {Object} シリアライズされた面情報
   * @private
   */
  _serializePolygon(polygon) {
    const result = {
      id: polygon.id,
      vertexIds: polygon.vertexIds && polygon.vertexIds.length > 0 ? [...polygon.vertexIds] : null,
      holesVertexIds: polygon.holesVertexIds.map(hole => [...hole]),
      properties: polygon.properties.map(prop => this._serializeProperty(prop)),
      layerId: polygon.layerId,
      parentId: polygon.parentId,
      childIds: [...polygon.childIds],
      isMultiPolygon: polygon.isMultiPolygon
    };
    
    if (polygon.isMultiPolygon) {
      result.subPolygons = polygon.subPolygons.map(subPoly => ({
        vertexIds: [...subPoly.vertexIds],
        holesVertexIds: subPoly.holesVertexIds.map(hole => [...hole])
      }));
    }
    
    return result;
  }

  /**
   * 面情報をデシリアライズ
   * @param {Object} data - シリアライズされた面情報
   * @returns {Polygon} 面情報
   * @private
   */
  _deserializePolygon(data) {
    return new Polygon(
      data.id,
      data.vertexIds || [],
      data.properties.map(prop => this._deserializeProperty(prop)),
      data.layerId,
      data.holesVertexIds || [],
      data.parentId || "0",
      data.childIds || [],
      data.isMultiPolygon || false,
      data.subPolygons || []
    );
  }
}

// src/infrastructure/persistence/JSONWorldRepository.js
import { WorldRepository } from '../../application/WorldRepository';

/**
 * JSONファイルベースのリポジトリ実装
 */
export class JSONWorldRepository extends WorldRepository {
  /**
   * リポジトリを作成
   * @param {FileSystem} fileSystem - ファイルシステム
   * @param {JSONSerializer} serializer - JSONシリアライザ
   * @param {string} [filePath="world.json"] - 保存ファイルパス
   */
  constructor(fileSystem, serializer, filePath = "world.json") {
    super();
    this._fileSystem = fileSystem;
    this._serializer = serializer;
    this._filePath = filePath;
    this._world = null; // キャッシュ
  }

  /**
   * 世界データの読み込み
   * @returns {Promise<Object>} 世界データ
   */
  async getWorld() {
    // キャッシュがあればそれを返す
    if (this._world) {
      return this._world;
    }
    
    try {
      // ファイルが存在するかチェック
      const exists = await this._fileSystem.fileExists(this._filePath);
      
      if (exists) {
        // ファイルからデータを読み込む
        const data = await this._fileSystem.readFile(this._filePath);
        this._world = this._serializer.deserialize(data);
      } else {
        // 新しい世界データを作成
        this._world = this._createEmptyWorld();
      }
      
      return this._world;
    } catch (error) {
      throw new Error(`Failed to load world data: ${error.message}`);
    }
  }

  /**
   * 世界データの保存
   * @param {Object} world - 保存する世界データ
   * @returns {Promise<void>}
   */
  async saveWorld(world) {
    try {
      // ファイルが存在する場合はバックアップを作成
      const exists = await this._fileSystem.fileExists(this._filePath);
      if (exists) {
        await this._fileSystem.createBackup(this._filePath);
      }
      
      // データをシリアライズしてファイルに保存
      const data = this._serializer.serialize(world);
      await this._fileSystem.writeFile(this._filePath, data);
      
      // キャッシュを更新
      this._world = world;
    } catch (error) {
      throw new Error(`Failed to save world data: ${error.message}`);
    }
  }

  /**
   * 保存ファイルパスの変更
   * @param {string} newFilePath - 新しいファイルパス
   */
  setFilePath(newFilePath) {
    this._filePath = newFilePath;
    this._world = null; // キャッシュをクリア
  }

  /**
   * 空の世界データを作成
   * @returns {Object} 空の世界データ
   * @private
   */
  _createEmptyWorld() {
    return {
      layers: [
        {
          id: "layer-base",
          name: "基本レイヤー",
          order: 0,
          visible: true,
          opacity: 1.0,
          description: "最初のレイヤー"
        }
      ],
      vertices: [],
      features: [],
      metadata: {
        sliderMin: 0,
        sliderMax: 10000,
        worldName: "新しい世界",
        worldDescription: "",
        settings: {
          zoomMin: 1,
          zoomMax: 50,
          gridInterval: 10,
          autoSaveInterval: 300
        }
      }
    };
  }
}

// src/infrastructure/rendering/SVGRenderer.js
/**
 * SVGベースの地図レンダリング
 */
export class SVGRenderer {
  /**
   * レンダラーを作成
   * @param {HTMLElement} container - SVG要素を配置するコンテナ
   * @param {Object} [options={}] - レンダリングオプション
   */
  constructor(container, options = {}) {
    this._container = container;
    this._svg = null;
    this._defs = null;
    this._mainGroup = null;
    this._gridGroup = null;
    this._featuresGroup = null;
    
    this._options = {
      width: options.width || 800,
      height: options.height || 600,
      padding: options.padding || 10,
      gridColor: options.gridColor || "#cccccc",
      gridOpacity: options.gridOpacity || 0.5,
      ...options
    };
    
    this._initSVG();
  }

  /**
   * SVG要素の初期化
   * @private
   */
  _initSVG() {
    // SVG要素を作成
    this._svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    this._svg.setAttribute("width", this._options.width);
    this._svg.setAttribute("height", this._options.height);
    this._svg.setAttribute("viewBox", `0 0 ${this._options.width} ${this._options.height}`);
    this._svg.style.display = "block";
    
    // グループ要素を作成
    this._defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
    this._svg.appendChild(this._defs);
    
    this._mainGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
    this._mainGroup.setAttribute("class", "main-group");
    this._svg.appendChild(this._mainGroup);
    
    this._gridGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
    this._gridGroup.setAttribute("class", "grid-group");
    this._mainGroup.appendChild(this._gridGroup);
    
    this._featuresGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
    this._featuresGroup.setAttribute("class", "features-group");
    this._mainGroup.appendChild(this._featuresGroup);
    
    // コンテナに追加
    this._container.appendChild(this._svg);
  }

  /**
   * SVG要素のサイズを変更
   * @param {number} width - 新しい幅
   * @param {number} height - 新しい高さ
   */
  resize(width, height) {
    this._options.width = width;
    this._options.height = height;
    
    this._svg.setAttribute("width", width);
    this._svg.setAttribute("height", height);
    this._svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
  }

  /**
   * 地図を描画
   * @param {Object} world - 世界データ
   * @param {Object} viewport - ビューポート情報 { x, y, zoom, width, height }
   * @param {TimePoint} currentTime - 現在の時間点
   */
  render(world, viewport, currentTime) {
    // グリッドを描画
    this._renderGrid(viewport);
    
    // 特徴を描画
    this._clearFeatures();
    
    // レイヤーを順序でソート
    const sortedLayers = [...world.layers].sort((a, b) => a.order - b.order);
    
    // レイヤーごとに特徴を描画
    for (const layer of sortedLayers) {
      if (!layer.visible) continue;
      
      const layerGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
      layerGroup.setAttribute("class", `layer-${layer.id}`);
      layerGroup.style.opacity = layer.opacity;
      
      // このレイヤーに属する特徴をフィルタリング
      const layerFeatures = world.features.filter(f => 
        f.layerId === layer.id && f.existsAt(currentTime)
      );
      
      // 特徴を種類別に分けて描画順序を制御
      const polygons = layerFeatures.filter(f => f instanceof Polygon);
      const lines = layerFeatures.filter(f => f instanceof Line);
      const points = layerFeatures.filter(f => f instanceof Point);
      
      // 面 → 線 → 点の順で描画
      for (const polygon of polygons) {
        const element = this._renderPolygon(polygon, world.vertices, currentTime, viewport);
        if (element) {
          layerGroup.appendChild(element);
        }
      }
      
      for (const line of lines) {
        const element = this._renderLine(line, world.vertices, currentTime, viewport);
        if (element) {
          layerGroup.appendChild(element);
        }
      }
      
      for (const point of points) {
        const element = this._renderPoint(point, world.vertices, currentTime, viewport);
        if (element) {
          layerGroup.appendChild(element);
        }
      }
      
      this._featuresGroup.appendChild(layerGroup);
    }
  }

  /**
   * 特徴要素をクリア
   * @private
   */
  _clearFeatures() {
    while (this._featuresGroup.firstChild) {
      this._featuresGroup.removeChild(this._featuresGroup.firstChild);
    }
  }

  /**
   * グリッドを描画
   * @param {Object} viewport - ビューポート情報
   * @private
   */
  _renderGrid(viewport) {
    // グリッドをクリア
    while (this._gridGroup.firstChild) {
      this._gridGroup.removeChild(this._gridGroup.firstChild);
    }
    
    const { x, y, zoom, width, height } = viewport;
    
    // グリッド間隔（度単位）
    const gridInterval = this._options.gridInterval;
    
    // 描画領域の範囲（経度・緯度）
    const left = x - width / 2 / zoom;
    const right = x + width / 2 / zoom;
    const top = y - height / 2 / zoom;
    const bottom = y + height / 2 / zoom;
    
    // 緯線（横線）を描画
    const latStep = gridInterval;
    for (let lat = Math.floor(top / latStep) * latStep; lat <= bottom; lat += latStep) {
      // 赤道（0度）は強調表示
      const isEquator = Math.abs(lat) < 0.001;
      
      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute("x1", this._toScreenX(left, viewport));
      line.setAttribute("y1", this._toScreenY(lat, viewport));
      line.setAttribute("x2", this._toScreenX(right, viewport));
      line.setAttribute("y2", this._toScreenY(lat, viewport));
      line.setAttribute("stroke", isEquator ? "#ff0000" : this._options.gridColor);
      line.setAttribute("stroke-width", isEquator ? 2 : 1);
      line.setAttribute("opacity", this._options.gridOpacity);
      
      this._gridGroup.appendChild(line);
      
      // 緯度ラベル
      if (Math.abs(lat) > 0.001) {
        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
        text.setAttribute("x", this._toScreenX(left + 1, viewport));
        text.setAttribute("y", this._toScreenY(lat, viewport) - 5);
        text.setAttribute("font-size", "10");
        text.setAttribute("fill", this._options.gridColor);
        text.textContent = `${Math.abs(lat)}°${lat >= 0 ? 'N' : 'S'}`;
        
        this._gridGroup.appendChild(text);
      }
    }
    
    // 経線（縦線）を描画
    const lngStep = gridInterval;
    for (let lng = Math.floor(left / lngStep) * lngStep; lng <= right; lng += lngStep) {
      // 本初子午線（0度）と日付変更線（180度）は強調表示
      const isPrimeMeridian = Math.abs(lng) < 0.001;
      const isDateLine = Math.abs(Math.abs(lng) - 180) < 0.001;
      
      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute("x1", this._toScreenX(lng, viewport));
      line.setAttribute("y1", this._toScreenY(top, viewport));
      line.setAttribute("x2", this._toScreenX(lng, viewport));
      line.setAttribute("y2", this._toScreenY(bottom, viewport));
      line.setAttribute("stroke", isPrimeMeridian || isDateLine ? "#ff0000" : this._options.gridColor);
      line.setAttribute("stroke-width", isPrimeMeridian || isDateLine ? 2 : 1);
      line.setAttribute("opacity", this._options.gridOpacity);
      
      this._gridGroup.appendChild(line);
      
      // 経度ラベル
      if (!isPrimeMeridian) {
        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
        text.setAttribute("x", this._toScreenX(lng, viewport) + 5);
        text.setAttribute("y", this._toScreenY(top + 1, viewport));
        text.setAttribute("font-size", "10");
        text.setAttribute("fill", this._options.gridColor);
        text.textContent = `${Math.abs(lng)}°${lng >= 0 ? 'E' : 'W'}`;
        
        this._gridGroup.appendChild(text);
      }
    }
  }

  /**
   * 点情報を描画
   * @param {Point} point - 点情報
   * @param {Vertex[]} vertices - 頂点配列
   * @param {TimePoint} currentTime - 現在の時間点
   * @param {Object} viewport - ビューポート情報
   * @returns {SVGElement} SVG要素
   * @private
   */
  _renderPoint(point, vertices, currentTime, viewport) {
    const property = point.getPropertyAt(currentTime);
    if (!property) return null;
    
    // 頂点を取得
    const vertexId = point.vertexId;
    const vertex = vertices.find(v => v.id === vertexId);
    if (!vertex) return null;
    
    // カテゴリに基づいたスタイルを取得
    const style = this._getPointStyle(property);
    
    // グループ要素を作成
    const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
    group.setAttribute("class", `point-${point.id}`);
    group.setAttribute("data-id", point.id);
    
    // 点を描画
    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    circle.setAttribute("cx", this._toScreenX(vertex.x, viewport));
    circle.setAttribute("cy", this._toScreenY(vertex.y, viewport));
    circle.setAttribute("r", style.radius);
    circle.setAttribute("fill", style.fill);
    circle.setAttribute("stroke", style.stroke);
    circle.setAttribute("stroke-width", style.strokeWidth);
    
    group.appendChild(circle);
    
    // ラベルを描画（オプション）
    if (property.name && style.showLabel) {
      const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
      text.setAttribute("x", this._toScreenX(vertex.x, viewport));
      text.setAttribute("y", this._toScreenY(vertex.y, viewport) - style.radius - 5);
      text.setAttribute("text-anchor", "middle");
      text.setAttribute("font-size", style.fontSize);
      text.setAttribute("fill", style.textColor);
      text.textContent = property.name;
      
      group.appendChild(text);
    }
    
    return group;
  }

  /**
   * 線情報を描画
   * @param {Line} line - 線情報
   * @param {Vertex[]} vertices - 頂点配列
   * @param {TimePoint} currentTime - 現在の時間点
   * @param {Object} viewport - ビューポート情報
   * @returns {SVGElement} SVG要素
   * @private
   */
  _renderLine(line, vertices, currentTime, viewport) {
    const property = line.getPropertyAt(currentTime);
    if (!property) return null;
    
    // 頂点を取得
    const lineVertices = line.vertexIds.map(id => vertices.find(v => v.id === id));
    if (lineVertices.some(v => !v)) return null;
    
    // カテゴリに基づいたスタイルを取得
    const style = this._getLineStyle(property);
    
    // グループ要素を作成
    const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
    group.setAttribute("class", `line-${line.id}`);
    group.setAttribute("data-id", line.id);
    
    // パスを作成
    const pathElement = document.createElementNS("http://www.w3.org/2000/svg", "path");
    
    // パスデータを構築
    let pathData = `M ${this._toScreenX(lineVertices[0].x, viewport)} ${this._toScreenY(lineVertices[0].y, viewport)}`;
    
    for (let i = 1; i < lineVertices.length; i++) {
      pathData += ` L ${this._toScreenX(lineVertices[i].x, viewport)} ${this._toScreenY(lineVertices[i].y, viewport)}`;
    }
    
    pathElement.setAttribute("d", pathData);
    pathElement.setAttribute("fill", "none");
    pathElement.setAttribute("stroke", style.stroke);
    pathElement.setAttribute("stroke-width", style.strokeWidth);
    pathElement.setAttribute("stroke-dasharray", style.strokeDasharray || "");
    
    group.appendChild(pathElement);
    
    // ラベルを描画（オプション）
    if (property.name && style.showLabel) {
      // 線の中央位置を計算
      const midIndex = Math.floor(lineVertices.length / 2);
      const x = this._toScreenX(lineVertices[midIndex].x, viewport);
      const y = this._toScreenY(lineVertices[midIndex].y, viewport);
      
      const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
      text.setAttribute("x", x);
      text.setAttribute("y", y - 5);
      text.setAttribute("text-anchor", "middle");
      text.setAttribute("font-size", style.fontSize);
      text.setAttribute("fill", style.textColor);
      text.textContent = property.name;
      
      group.appendChild(text);
    }
    
    return group;
  }

  /**
   * 面情報を描画
   * @param {Polygon} polygon - 面情報
   * @param {Vertex[]} vertices - 頂点配列
   * @param {TimePoint} currentTime - 現在の時間点
   * @param {Object} viewport - ビューポート情報
   * @returns {SVGElement} SVG要素
   * @private
   */
  _renderPolygon(polygon, vertices, currentTime, viewport) {
    const property = polygon.getPropertyAt(currentTime);
    if (!property) return null;
    
    // グループ要素を作成
    const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
    group.setAttribute("class", `polygon-${polygon.id}`);
    group.setAttribute("data-id", polygon.id);
    
    // カテゴリに基づいたスタイルを取得
    const style = this._getPolygonStyle(property);
    
    if (polygon.isMultiPolygon) {
      // 飛び地の描画
      for (const subPoly of polygon.subPolygons) {
        const subVertices = subPoly.vertexIds.map(id => vertices.find(v => v.id === id));
        if (subVertices.some(v => !v)) continue;
        
        const path = this._createPolygonPath(subVertices, subPoly.holesVertexIds, vertices, viewport);
        path.setAttribute("fill", style.fill);
        path.setAttribute("stroke", style.stroke);
        path.setAttribute("stroke-width", style.strokeWidth);
        path.setAttribute("opacity", style.fillOpacity);
        
        group.appendChild(path);
      }
    } else if (polygon.vertexIds && polygon.vertexIds.length > 0) {
      // 通常の多角形
      const polyVertices = polygon.vertexIds.map(id => vertices.find(v => v.id === id));
      if (polyVertices.some(v => !v)) return null;
      
      const path = this._createPolygonPath(polyVertices, polygon.holesVertexIds, vertices, viewport);
      path.setAttribute("fill", style.fill);
      path.setAttribute("stroke", style.stroke);
      path.setAttribute("stroke-width", style.strokeWidth);
      path.setAttribute("opacity", style.fillOpacity);
      
      group.appendChild(path);
    } else if (polygon.childIds && polygon.childIds.length > 0) {
      // 子ポリゴンから構成される多角形の処理
      // この簡易実装では省略
    }
    
    // ラベルを描画（オプション）
    if (property.name && style.showLabel) {
      // 多角形の中心を計算
      let centroidX = 0;
      let centroidY = 0;
      let vertexCount = 0;
      
      // 通常ポリゴンの場合
      if (!polygon.isMultiPolygon && polygon.vertexIds && polygon.vertexIds.length > 0) {
        const polyVertices = polygon.vertexIds.map(id => vertices.find(v => v.id === id)).filter(v => v);
        vertexCount = polyVertices.length;
        
        for (const vertex of polyVertices) {
          centroidX += vertex.x;
          centroidY += vertex.y;
        }
      } 
      // 飛び地の場合、最初のサブポリゴンの中心を使用
      else if (polygon.isMultiPolygon && polygon.subPolygons.length > 0) {
        const subVertices = polygon.subPolygons[0].vertexIds
          .map(id => vertices.find(v => v.id === id))
          .filter(v => v);
        
        vertexCount = subVertices.length;
        
        for (const vertex of subVertices) {
          centroidX += vertex.x;
          centroidY += vertex.y;
        }
      }
      
      if (vertexCount > 0) {
        centroidX /= vertexCount;
        centroidY /= vertexCount;
        
        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
        text.setAttribute("x", this._toScreenX(centroidX, viewport));
        text.setAttribute("y", this._toScreenY(centroidY, viewport));
        text.setAttribute("text-anchor", "middle");
        text.setAttribute("font-size", style.fontSize);
        text.setAttribute("fill", style.textColor);
        text.textContent = property.name;
        
        group.appendChild(text);
      }
    }
    
    return group;
  }

  /**
   * 多角形パスを作成
   * @param {Vertex[]} vertices - 頂点配列
   * @param {string[][]} holesVertexIds - 穴の頂点IDの配列の配列
   * @param {Vertex[]} allVertices - すべての頂点
   * @param {Object} viewport - ビューポート情報
   * @returns {SVGElement} パス要素
   * @private
   */
  _createPolygonPath(vertices, holesVertexIds, allVertices, viewport) {
    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    
    // 外周のパスデータ
    let pathData = `M ${this._toScreenX(vertices[0].x, viewport)} ${this._toScreenY(vertices[0].y, viewport)}`;
    
    for (let i = 1; i < vertices.length; i++) {
      pathData += ` L ${this._toScreenX(vertices[i].x, viewport)} ${this._toScreenY(vertices[i].y, viewport)}`;
    }
    
    pathData += " Z";
    
    // 穴のパスデータ
    for (const holeIds of holesVertexIds) {
      const holeVertices = holeIds.map(id => allVertices.find(v => v.id === id)).filter(v => v);
      
      if (holeVertices.length > 0) {
        pathData += ` M ${this._toScreenX(holeVertices[0].x, viewport)} ${this._toScreenY(holeVertices[0].y, viewport)}`;
        
        for (let i = 1; i < holeVertices.length; i++) {
          pathData += ` L ${this._toScreenX(holeVertices[i].x, viewport)} ${this._toScreenY(holeVertices[i].y, viewport)}`;
        }
        
        pathData += " Z";
      }
    }
    
    path.setAttribute("d", pathData);
    return path;
  }

  /**
   * 世界座標からスクリーン座標へのX変換
   * @param {number} worldX - 世界X座標
   * @param {Object} viewport - ビューポート情報
   * @returns {number} スクリーンX座標
   * @private
   */
  _toScreenX(worldX, viewport) {
    const { x, zoom, width } = viewport;
    return (worldX - x) * zoom + width / 2;
  }

  /**
   * 世界座標からスクリーン座標へのY変換
   * @param {number} worldY - 世界Y座標
   * @param {Object} viewport - ビューポート情報
   * @returns {number} スクリーンY座標
   * @private
   */
  _toScreenY(worldY, viewport) {
    const { y, zoom, height } = viewport;
    return (worldY - y) * zoom + height / 2;
  }

  /**
   * スクリーン座標から世界座標へのX変換
   * @param {number} screenX - スクリーンX座標
   * @param {Object} viewport - ビューポート情報
   * @returns {number} 世界X座標
   */
  toWorldX(screenX, viewport) {
    const { x, zoom, width } = viewport;
    return (screenX - width / 2) / zoom + x;
  }

  /**
   * スクリーン座標から世界座標へのY変換
   * @param {number} screenY - スクリーンY座標
   * @param {Object} viewport - ビューポート情報
   * @returns {number} 世界Y座標
   */
  toWorldY(screenY, viewport) {
    const { y, zoom, height } = viewport;
    return (screenY - height / 2) / zoom + y;
  }

  /**
   * 点のスタイルを取得
   * @param {Property} property - プロパティ
   * @returns {Object} スタイル情報
   * @private
   */
  _getPointStyle(property) {
    // カテゴリに基づいたスタイルのマッピング
    const categoryStyles = {
      city: {
        radius: 5,
        fill: "#ff0000",
        stroke: "#000000",
        strokeWidth: 1,
        textColor: "#000000",
        fontSize: 12,
        showLabel: true
      },
      town: {
        radius: 3,
        fill: "#ff3333",
        stroke: "#000000",
        strokeWidth: 1,
        textColor: "#000000",
        fontSize: 10,
        showLabel: true
      },
      battle: {
        radius: 4,
        fill: "#ff0000",
        stroke: "#000000",
        strokeWidth: 1,
        textColor: "#000000",
        fontSize: 10,
        showLabel: true
      },
      ruin: {
        radius: 4,
        fill: "#996633",
        stroke: "#000000",
        strokeWidth: 1,
        textColor: "#000000",
        fontSize: 10,
        showLabel: true
      },
      // デフォルトスタイル
      default: {
        radius: 4,
        fill: "#3388ff",
        stroke: "#000000",
        strokeWidth: 1,
        textColor: "#000000",
        fontSize: 10,
        showLabel: true
      }
    };
    
    const category = property.getAttribute("category", "default");
    return categoryStyles[category] || categoryStyles.default;
  }

  /**
   * 線のスタイルを取得
   * @param {Property} property - プロパティ
   * @returns {Object} スタイル情報
   * @private
   */
  _getLineStyle(property) {
    // カテゴリに基づいたスタイルのマッピング
    const categoryStyles = {
      road: {
        stroke: "#996633",
        strokeWidth: 2,
        strokeDasharray: "",
        textColor: "#000000",
        fontSize: 10,
        showLabel: true
      },
      railway: {
        stroke: "#333333",
        strokeWidth: 2,
        strokeDasharray: "5,5",
        textColor: "#000000",
        fontSize: 10,
        showLabel: true
      },
      river: {
        stroke: "#3388ff",
        strokeWidth: 2,
        strokeDasharray: "",
        textColor: "#000000",
        fontSize: 10,
        showLabel: true
      },
      trade_route: {
        stroke: "#ff8800",
        strokeWidth: 2,
        strokeDasharray: "10,2",
        textColor: "#000000",
        fontSize: 10,
        showLabel: true
      },
      border: {
        stroke: "#ff0000",
        strokeWidth: 3,
        strokeDasharray: "",
        textColor: "#000000",
        fontSize: 10,
        showLabel: false
      },
      // デフォルトスタイル
      default: {
        stroke: "#3388ff",
        strokeWidth: 2,
        strokeDasharray: "",
        textColor: "#000000",
        fontSize: 10,
        showLabel: true
      }
    };
    
    const category = property.getAttribute("category", "default");
    return categoryStyles[category] || categoryStyles.default;
  }

  /**
   * 面のスタイルを取得
   * @param {Property} property - プロパティ
   * @returns {Object} スタイル情報
   * @private
   */
  _getPolygonStyle(property) {
    // カテゴリに基づいたスタイルのマッピング
    const categoryStyles = {
      kingdom: {
        fill: "#ff8888",
        stroke: "#ff0000",
        strokeWidth: 2,
        fillOpacity: 0.6,
        textColor: "#000000",
        fontSize: 14,
        showLabel: true
      },
      empire: {
        fill: "#8888ff",
        stroke: "#0000ff",
        strokeWidth: 2,
        fillOpacity: 0.6,
        textColor: "#000000",
        fontSize: 16,
        showLabel: true
      },
      province: {
        fill: "#88ff88",
        stroke: "#008800",
        strokeWidth: 2,
        fillOpacity: 0.6,
        textColor: "#000000",
        fontSize: 12,
        showLabel: true
      },
      ocean: {
        fill: "#3388ff",
        stroke: "#3388ff",
        strokeWidth: 1,
        fillOpacity: 0.4,
        textColor: "#000000",
        fontSize: 14,
        showLabel: true
      },
      lake: {
        fill: "#3388ff",
        stroke: "#3388ff",
        strokeWidth: 1,
        fillOpacity: 0.6,
        textColor: "#000000",
        fontSize: 12,
        showLabel: true
      },
      // デフォルトスタイル
      default: {
        fill: "#ffcc88",
        stroke: "#ff8800",
        strokeWidth: 2,
        fillOpacity: 0.6,
        textColor: "#000000",
        fontSize: 12,
        showLabel: true
      }
    };
    
    const category = property.getAttribute("category", "default");
    return categoryStyles[category] || categoryStyles.default;
  }

  /**
   * 点を描画
   * @param {number} x - 世界X座標
   * @param {number} y - 世界Y座標
   * @param {Object} style - スタイル情報
   * @param {Object} viewport - ビューポート情報
   * @returns {SVGElement} SVG要素
   */
  drawPoint(x, y, style, viewport) {
    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    circle.setAttribute("cx", this._toScreenX(x, viewport));
    circle.setAttribute("cy", this._toScreenY(y, viewport));
    circle.setAttribute("r", style.radius || 5);
    circle.setAttribute("fill", style.fill || "#ff0000");
    circle.setAttribute("stroke", style.stroke || "#000000");
    circle.setAttribute("stroke-width", style.strokeWidth || 1);
    
    this._mainGroup.appendChild(circle);
    return circle;
  }

  /**
   * 線を描画
   * @param {Array<{x: number, y: number}>} points - 点の配列
   * @param {Object} style - スタイル情報
   * @param {Object} viewport - ビューポート情報
   * @returns {SVGElement} SVG要素
   */
  drawLine(points, style, viewport) {
    const line = document.createElementNS("http://www.w3.org/2000/svg", "path");
    
    let pathData = `M ${this._toScreenX(points[0].x, viewport)} ${this._toScreenY(points[0].y, viewport)}`;
    
    for (let i = 1; i < points.length; i++) {
      pathData += ` L ${this._toScreenX(points[i].x, viewport)} ${this._toScreenY(points[i].y, viewport)}`;
    }
    
    line.setAttribute("d", pathData);
    line.setAttribute("fill", "none");
    line.setAttribute("stroke", style.stroke || "#000000");
    line.setAttribute("stroke-width", style.strokeWidth || 2);
    line.setAttribute("stroke-dasharray", style.strokeDasharray || "");
    
    this._mainGroup.appendChild(line);
    return line;
  }

  /**
   * テキストを描画
   * @param {number} x - 世界X座標
   * @param {number} y - 世界Y座標
   * @param {string} content - テキスト内容
   * @param {Object} style - スタイル情報
   * @param {Object} viewport - ビューポート情報
   * @returns {SVGElement} SVG要素
   */
  drawText(x, y, content, style, viewport) {
    const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
    text.setAttribute("x", this._toScreenX(x, viewport));
    text.setAttribute("y", this._toScreenY(y, viewport));
    text.setAttribute("text-anchor", style.textAnchor || "middle");
    text.setAttribute("font-size", style.fontSize || 12);
    text.setAttribute("fill", style.textColor || "#000000");
    text.textContent = content;
    
    this._mainGroup.appendChild(text);
    return text;
  }

  /**
   * 要素を削除
   * @param {SVGElement} element - 削除する要素
   */
  removeElement(element) {
    if (element && element.parentNode) {
      element.parentNode.removeChild(element);
    }
  }
}

// src/infrastructure/rendering/ViewportManager.js
/**
 * ビューポート管理（ズーム、パンなど）
 */
export class ViewportManager {
  /**
   * ビューポートマネージャーを作成
   * @param {Object} [options={}] - ビューポートオプション
   */
  constructor(options = {}) {
    this._viewport = {
      x: options.x || 0,
      y: options.y || 0,
      zoom: options.zoom || 1,
      width: options.width || 800,
      height: options.height || 600,
      minZoom: options.minZoom || 0.1,
      maxZoom: options.maxZoom || 10
    };
    
    this._listeners = [];
    this._isDragging = false;
    this._dragStart = { x: 0, y: 0 };
    this._viewportStart = { x: 0, y: 0 };
  }

  /**
   * 現在のビューポート情報を取得
   * @returns {Object} ビューポート情報
   */
  getViewport() {
    return { ...this._viewport };
  }

  /**
   * ビューポートを更新
   * @param {Object} updates - 更新内容
   */
  updateViewport(updates) {
    const oldViewport = { ...this._viewport };
    
    // ビューポートを更新
    Object.assign(this._viewport, updates);
    
    // ズーム制限を適用
    this._viewport.zoom = Math.max(
      this._viewport.minZoom,
      Math.min(this._viewport.maxZoom, this._viewport.zoom)
    );
    
    // ビューポートに変更があった場合のみリスナーを呼び出す
    if (this._hasViewportChanged(oldViewport, this._viewport)) {
      this._notifyListeners();
    }
  }

  /**
   * ビューポートのサイズを変更
   * @param {number} width - 新しい幅
   * @param {number} height - 新しい高さ
   */
  resize(width, height) {
    this.updateViewport({ width, height });
  }

  /**
   * 中心座標を変更
   * @param {number} x - 新しいX座標
   * @param {number} y - 新しいY座標
   */
  setCenter(x, y) {
    this.updateViewport({ x, y });
  }

  /**
   * 中心座標を指定量だけ移動
   * @param {number} dx - X方向の移動量
   * @param {number} dy - Y方向の移動量
   */
  pan(dx, dy) {
    // ズームレベルに合わせて移動量を調整
    const adjustedDx = dx / this._viewport.zoom;
    const adjustedDy = dy / this._viewport.zoom;
    
    this.updateViewport({
      x: this._viewport.x - adjustedDx,
      y: this._viewport.y - adjustedDy
    });
  }

  /**
   * ズームレベルを変更
   * @param {number} zoom - 新しいズームレベル
   */
  setZoom(zoom) {
    this.updateViewport({ zoom });
  }

  /**
   * 特定の地点を中心にズーム
   * @param {number} x - 世界X座標
   * @param {number} y - 世界Y座標
   * @param {number} zoomDelta - ズーム量の変化
   */
  zoomAt(x, y, zoomDelta) {
    const oldZoom = this._viewport.zoom;
    const newZoom = Math.max(
      this._viewport.minZoom,
      Math.min(this._viewport.maxZoom, oldZoom * (1 + zoomDelta))
    );
    
    // ズーム中心点の調整
    const viewportX = this._viewport.x;
    const viewportY = this._viewport.y;
    
    const dx = x - viewportX;
    const dy = y - viewportY;
    
    const scaleFactor = newZoom / oldZoom;
    
    this.updateViewport({
      zoom: newZoom,
      x: viewportX - dx * (scaleFactor - 1) / scaleFactor,
      y: viewportY - dy * (scaleFactor - 1) / scaleFactor
    });
  }

  /**
   * ドラッグ開始
   * @param {number} screenX - スクリーンX座標
   * @param {number} screenY - スクリーンY座標
   */
  startDrag(screenX, screenY) {
    this._isDragging = true;
    this._dragStart = { x: screenX, y: screenY };
    this._viewportStart = { x: this._viewport.x, y: this._viewport.y };
  }

  /**
   * ドラッグ中
   * @param {number} screenX - スクリーンX座標
   * @param {number} screenY - スクリーンY座標
   */
  drag(screenX, screenY) {
    if (!this._isDragging) return;
    
    const dx = screenX - this._dragStart.x;
    const dy = screenY - this._dragStart.y;
    
    // ズームレベルに合わせて移動量を調整
    const adjustedDx = dx / this._viewport.zoom;
    const adjustedDy = dy / this._viewport.zoom;
    
    this.updateViewport({
      x: this._viewportStart.x - adjustedDx,
      y: this._viewportStart.y - adjustedDy
    });
  }

  /**
   * ドラッグ終了
   */
  endDrag() {
    this._isDragging = false;
  }

  /**
   * 経度を一定量シフト
   * @param {number} degrees - シフトする度数
   */
  shiftLongitude(degrees) {
    this.updateViewport({ x: this._viewport.x + degrees });
  }

  /**
   * ビューポート変更リスナーを追加
   * @param {Function} listener - コールバック関数
   */
  addListener(listener) {
    this._listeners.push(listener);
  }

  /**
   * ビューポート変更リスナーを削除
   * @param {Function} listener - 削除するリスナー
   */
  removeListener(listener) {
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }

  /**
   * ビューポートが変更されたかチェック
   * @param {Object} oldViewport - 古いビューポート
   * @param {Object} newViewport - 新しいビューポート
   * @returns {boolean} 変更があればtrue
   * @private
   */
  _hasViewportChanged(oldViewport, newViewport) {
    return oldViewport.x !== newViewport.x ||
           oldViewport.y !== newViewport.y ||
           oldViewport.zoom !== newViewport.zoom ||
           oldViewport.width !== newViewport.width ||
           oldViewport.height !== newViewport.height;
  }

  /**
   * ビューポート変更を通知
   * @private
   */
  _notifyListeners() {
    const viewport = this.getViewport();
    for (const listener of this._listeners) {
      listener(viewport);
    }
  }

  /**
   * 画面座標から世界座標へ変換
   * @param {number} screenX - スクリーンX座標
   * @param {number} screenY - スクリーンY座標
   * @returns {Object} 世界座標 { x, y }
   */
  screenToWorld(screenX, screenY) {
    const { x, y, zoom, width, height } = this._viewport;
    
    return {
      x: (screenX - width / 2) / zoom + x,
      y: (screenY - height / 2) / zoom + y
    };
  }

  /**
   * 世界座標から画面座標へ変換
   * @param {number} worldX - 世界X座標
   * @param {number} worldY - 世界Y座標
   * @returns {Object} スクリーン座標 { x, y }
   */
  worldToScreen(worldX, worldY) {
    const { x, y, zoom, width, height } = this._viewport;
    
    return {
      x: (worldX - x) * zoom + width / 2,
      y: (worldY - y) * zoom + height / 2
    };
  }
}

// src/infrastructure/services/Logger.js
/**
 * ロギングサービス
 */
export class Logger {
  /**
   * ロガーを作成
   * @param {number} [level=3] - ログレベル（0-4）
   */
  constructor(level = 3) {
    this._level = level;
    this._levels = {
      ERROR: 1,
      WARN: 2,
      INFO: 3,
      DEBUG: 4
    };
  }

  /**
   * ログレベルを設定
   * @param {number} level - 新しいログレベル
   */
  setLevel(level) {
    this._level = level;
  }

  /**
   * エラーログ
   * @param {string} context - コンテキスト情報
   * @param {string} message - メッセージ
   * @param {Error} [error] - エラーオブジェクト
   */
  error(context, message, error) {
    if (this._level >= this._levels.ERROR) {
      this._log('ERROR', context, message, error);
    }
  }

  /**
   * 警告ログ
   * @param {string} context - コンテキスト情報
   * @param {string} message - メッセージ
   */
  warn(context, message) {
    if (this._level >= this._levels.WARN) {
      this._log('WARN', context, message);
    }
  }

  /**
   * 情報ログ
   * @param {string} context - コンテキスト情報
   * @param {string} message - メッセージ
   */
  info(context, message) {
    if (this._level >= this._levels.INFO) {
      this._log('INFO', context, message);
    }
  }

  /**
   * デバッグログ
   * @param {string} context - コンテキスト情報
   * @param {string} message - メッセージ
   */
  debug(context, message) {
    if (this._level >= this._levels.DEBUG) {
      this._log('DEBUG', context, message);
    }
  }

  /**
   * ログ出力
   * @param {string} level - ログレベル
   * @param {string} context - コンテキスト情報
   * @param {string} message - メッセージ
   * @param {Error} [error] - エラーオブジェクト
   * @private
   */
  _log(level, context, message, error) {
    const timestamp = new Date().toISOString();
    let logMessage = `[${level}] ${timestamp} [${context}] ${message}`;
    
    if (error) {
      logMessage += `\nStack: ${error.stack || error}`;
    }
    
    // レベルに応じた出力方法
    switch (level) {
      case 'ERROR':
        console.error(logMessage);
        break;
      case 'WARN':
        console.warn(logMessage);
        break;
      case 'INFO':
        console.info(logMessage);
        break;
      case 'DEBUG':
        console.debug(logMessage);
        break;
      default:
        console.log(logMessage);
    }
    
    // ここに外部ロギングシステムへの送信なども実装可能
  }
}

// src/infrastructure/services/ConfigManager.js
/**
 * 設定管理
 */
export class ConfigManager {
  /**
   * 設定マネージャーを作成
   * @param {string} [storageKey="time-map-config"] - ストレージキー
   * @param {Object} [defaultConfig={}] - デフォルト設定
   */
  constructor(storageKey = "time-map-config", defaultConfig = {}) {
    this._storageKey = storageKey;
    this._defaultConfig = {
      // 地図表示設定
      map: {
        zoomMin: 0.1,
        zoomMax: 10,
        gridInterval: 10,
        gridColor: "#cccccc",
        gridOpacity: 0.5,
        equatorLength: 40000 // 赤道長（km）
      },
      
      // 時間スライダー設定
      timeline: {
        minYear: 0,
        maxYear: 10000,
        stepSize: 1
      },
      
      // 自動保存設定
      autoSave: {
        enabled: true,
        interval: 300, // 秒
        maxBackups: 5
      },
      
      // UIレイアウト設定
      ui: {
        leftPanelWidth: 250,
        rightPanelWidth: 300,
        timelineHeight: 100,
        darkMode: false
      },
      
      // カスタムカレンダー設定
      calendar: {
        daysPerYear: 365.25,
        monthsPerYear: 12,
        daysPerMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
      },
      
      ...defaultConfig
    };
    
    this._config = this._loadConfig();
  }

  /**
   * 現在の設定を取得
   * @returns {Object} 設定オブジェクト
   */
  getConfig() {
    return JSON.parse(JSON.stringify(this._config));
  }

  /**
   * 特定のセクションの設定を取得
   * @param {string} section - セクション名
   * @returns {Object} セクション設定
   */
  getSection(section) {
    return JSON.parse(JSON.stringify(this._config[section] || {}));
  }

  /**
   * 特定の設定値を取得
   * @param {string} path - 設定パス（例: "map.zoomMax"）
   * @param {*} [defaultValue=null] - デフォルト値
   * @returns {*} 設定値
   */
  get(path, defaultValue = null) {
    const parts = path.split('.');
    let current = this._config;
    
    for (const part of parts) {
      if (current === undefined || current === null) {
        return defaultValue;
      }
      current = current[part];
    }
    
    return current !== undefined ? current : defaultValue;
  }

  /**
   * 設定を更新
   * @param {Object} updates - 更新内容
   */
  update(updates) {
    this._config = this._deepMerge(this._config, updates);
    this._saveConfig();
  }

  /**
   * セクション設定を更新
   * @param {string} section - セクション名
   * @param {Object} updates - 更新内容
   */
  updateSection(section, updates) {
    if (!this._config[section]) {
      this._config[section] = {};
    }
    
    this._config[section] = this._deepMerge(this._config[section], updates);
    this._saveConfig();
  }

  /**
   * 特定の設定値を更新
   * @param {string} path - 設定パス（例: "map.zoomMax"）
   * @param {*} value - 新しい値
   */
  set(path, value) {
    const parts = path.split('.');
    let current = this._config;
    
    for (let i = 0; i < parts.length - 1; i++) {
      const part = parts[i];
      if (current[part] === undefined) {
        current[part] = {};
      }
      current = current[part];
    }
    
    current[parts[parts.length - 1]] = value;
    this._saveConfig();
  }

  /**
   * 設定をリセット
   * @param {string} [section] - リセットするセクション（省略時は全体）
   */
  reset(section) {
    if (section) {
      this._config[section] = JSON.parse(JSON.stringify(this._defaultConfig[section] || {}));
    } else {
      this._config = JSON.parse(JSON.stringify(this._defaultConfig));
    }
    
    this._saveConfig();
  }

  /**
   * 設定を読み込み
   * @returns {Object} 設定オブジェクト
   * @private
   */
  _loadConfig() {
    try {
      const stored = localStorage.getItem(this._storageKey);
      if (stored) {
        const parsed = JSON.parse(stored);
        return this._deepMerge(JSON.parse(JSON.stringify(this._defaultConfig)), parsed);
      }
    } catch (error) {
      console.error("設定の読み込みに失敗しました", error);
    }
    
    return JSON.parse(JSON.stringify(this._defaultConfig));
  }

  /**
   * 設定を保存
   * @private
   */
  _saveConfig() {
    try {
      localStorage.setItem(this._storageKey, JSON.stringify(this._config));
    } catch (error) {
      console.error("設定の保存に失敗しました", error);
    }
  }

  /**
   * オブジェクトの深いマージ
   * @param {Object} target - ターゲットオブジェクト
   * @param {Object} source - ソースオブジェクト
   * @returns {Object} マージされたオブジェクト
   * @private
   */
  _deepMerge(target, source) {
    const output = { ...target };
    
    if (this._isObject(target) && this._isObject(source)) {
      Object.keys(source).forEach(key => {
        if (this._isObject(source[key])) {
          if (!(key in target)) {
            output[key] = source[key];
          } else {
            output[key] = this._deepMerge(target[key], source[key]);
          }
        } else {
          output[key] = source[key];
        }
      });
    }
    
    return output;
  }

  /**
   * オブジェクトかどうかをチェック
   * @param {*} item - チェックする項目
   * @returns {boolean} オブジェクトならtrue
   * @private
   */
  _isObject(item) {
    return (item && typeof item === 'object' && !Array.isArray(item));
  }
}

// src/presentation/view-models/MapViewModel.js
/**
 * マップビューのデータと状態管理
 */
export class MapViewModel {
  /**
   * マップビューモデルを作成
   * @param {EditFeatureUseCase} editFeatureUseCase - 地理オブジェクト編集ユースケース
   * @param {NavigateTimeUseCase} navigateTimeUseCase - 時間移動ユースケース
   * @param {ManageLayersUseCase} manageLayersUseCase - レイヤー管理ユースケース
   * @param {GeometryService} geometryService - 幾何学サービス
   * @param {EventBus} eventBus - イベントバス
   */
  constructor(
    editFeatureUseCase,
    navigateTimeUseCase,
    manageLayersUseCase,
    geometryService,
    eventBus
  ) {
    this._editFeatureUseCase = editFeatureUseCase;
    this._navigateTimeUseCase = navigateTimeUseCase;
    this._manageLayersUseCase = manageLayersUseCase;
    this._geometryService = geometryService;
    this._eventBus = eventBus;
    
    // マップの状態
    this._world = null;
    this._features = [];
    this._selectedFeature = null;
    this._selectedVertices = [];
    this._hoveredFeature = null;
    this._hoveredVertex = null;
    
    // 観測者の登録
    this._observers = [];
    
    // イベントリスナーの設定
    this._setupEventListeners();
  }

  /**
   * 世界データをロード
   * @returns {Promise<void>}
   */
  async loadWorld() {
    try {
      // 世界データを取得（リポジトリは外部から注入される）
      const worldRepository = this._editFeatureUseCase._worldRepository;
      this._world = await worldRepository.getWorld();
      
      // 現在の時間点に対応する特徴をフィルタリング
      await this._loadFeaturesForCurrentTime();
      
      this._notifyObservers('world');
    } catch (error) {
      console.error('世界データのロードに失敗しました', error);
      throw error;
    }
  }

  /**
   * 現在の時間点に対応する特徴をロード
   * @returns {Promise<void>}
   * @private
   */
  async _loadFeaturesForCurrentTime() {
    if (!this._world) return;
    
    const currentTime = this._navigateTimeUseCase.getCurrentTime();
    
    // 現在の時間点で存在する特徴をフィルタリング
    this._features = this._world.features.filter(feature => 
      feature.existsAt(currentTime)
    );
    
    this._notifyObservers('features');
  }

  /**
   * イベントリスナーの設定
   * @private
   */
  _setupEventListeners() {
    // 時間変更イベントの購読
    this._eventBus.subscribe('TimeChanged', this._onTimeChanged.bind(this));
    
    // 特徴追加イベントの購読
    this._eventBus.subscribe('FeatureAdded', this._onFeatureAdded.bind(this));
    
    // 特徴更新イベントの購読
    this._eventBus.subscribe('FeatureUpdated', this._onFeatureUpdated.bind(this));
    
    // 特徴削除イベントの購読
    this._eventBus.subscribe('FeatureDeleted', this._onFeatureDeleted.bind(this));
    
    // レイヤー表示変更イベントの購読
    this._eventBus.subscribe('LayerVisibilityChanged', this._onLayerVisibilityChanged.bind(this));
  }

  /**
   * 時間変更イベントのハンドラ
   * @param {Object} event - イベントデータ
   * @private
   */
  _onTimeChanged(event) {
    this._loadFeaturesForCurrentTime();
  }

  /**
   * 特徴追加イベントのハンドラ
   * @param {Object} event - イベントデータ
   * @private
   */
  _onFeatureAdded(event) {
    if (!this._world) return;
    
    // 世界データを更新
    if (!this._world.features.some(f => f.id === event.feature.id)) {
      this._world.features.push(event.feature);
    }
    
    // 現在の時間点に対応する特徴をリロード
    this._loadFeaturesForCurrentTime();
  }

  /**
   * 特徴更新イベントのハンドラ
   * @param {Object} event - イベントデータ
   * @private
   */
  _onFeatureUpdated(event) {
    if (!this._world) return;
    
    // 世界データを更新
    const index = this._world.features.findIndex(f => f.id === event.feature.id);
    if (index !== -1) {
      this._world.features[index] = event.feature;
    }
    
    // 現在の時間点に対応する特徴をリロード
    this._loadFeaturesForCurrentTime();
  }

  /**
   * 特徴削除イベントのハンドラ
   * @param {Object} event - イベントデータ
   * @private
   */
  _onFeatureDeleted(event) {
    if (!this._world) return;
    
    // 世界データを更新
    const index = this._world.features.findIndex(f => f.id === event.featureId);
    if (index !== -1) {
      this._world.features.splice(index, 1);
    }
    
    // 選択中の特徴が削除された場合、選択を解除
    if (this._selectedFeature && this._selectedFeature.id === event.featureId) {
      this._selectedFeature = null;
      this._selectedVertices = [];
      this._notifyObservers('selectedFeature');
    }
    
    // 現在の時間点に対応する特徴をリロード
    this._loadFeaturesForCurrentTime();
  }

  /**
   * レイヤー表示変更イベントのハンドラ
   * @param {Object} event - イベントデータ
   * @private
   */
  _onLayerVisibilityChanged(event) {
    if (!this._world) return;
    
    // レイヤーデータを更新
    const index = this._world.layers.findIndex(l => l.id === event.layerId);
    if (index !== -1) {
      this._world.layers[index] = event.layer;
    }
    
    this._notifyObservers('layers');
  }

  /**
   * 特徴を選択
   * @param {string} featureId - 選択する特徴のID
   */
  selectFeature(featureId) {
    if (!this._world) return;
    
    const feature = this._features.find(f => f.id === featureId);
    this._selectedFeature = feature || null;
    this._selectedVertices = [];
    
    this._notifyObservers('selectedFeature');
  }

  /**
   * 頂点を選択
   * @param {string} vertexId - 選択する頂点のID
   * @param {boolean} [addToSelection=false] - 選択に追加するかどうか
   */
  selectVertex(vertexId, addToSelection = false) {
    if (!this._world) return;
    
    const vertex = this._world.vertices.find(v => v.id === vertexId);
    
    if (vertex) {
      if (addToSelection) {
        // 既に選択されている場合は選択解除、そうでなければ追加
        const index = this._selectedVertices.findIndex(v => v.id === vertexId);
        if (index !== -1) {
          this._selectedVertices.splice(index, 1);
        } else {
          this._selectedVertices.push(vertex);
        }
      } else {
        // 単一選択
        this._selectedVertices = [vertex];
      }
    } else if (!addToSelection) {
      // 選択解除
      this._selectedVertices = [];
    }
    
    this._notifyObservers('selectedVertices');
  }

  /**
   * 選択を解除
   */
  clearSelection() {
    this._selectedFeature = null;
    this._selectedVertices = [];
    
    this._notifyObservers('selectedFeature');
    this._notifyObservers('selectedVertices');
  }

  /**
   * 特徴をホバー
   * @param {string} featureId - ホバーする特徴のID
   */
  hoverFeature(featureId) {
    if (!this._world) return;
    
    const feature = this._features.find(f => f.id === featureId);
    if (this._hoveredFeature !== feature) {
      this._hoveredFeature = feature || null;
      this._notifyObservers('hoveredFeature');
    }
  }

  /**
   * 頂点をホバー
   * @param {string} vertexId - ホバーする頂点のID
   */
  hoverVertex(vertexId) {
    if (!this._world) return;
    
    const vertex = this._world.vertices.find(v => v.id === vertexId);
    if (this._hoveredVertex !== vertex) {
      this._hoveredVertex = vertex || null;
      this._notifyObservers('hoveredVertex');
    }
  }

  /**
   * 頂点を移動
   * @param {string} vertexId - 移動する頂点のID
   * @param {Object} newPosition - 新しい位置 { x, y }
   * @returns {Promise<Object>} 更新情報
   */
  async moveVertex(vertexId, newPosition) {
    try {
      const result = await this._editFeatureUseCase.moveVertex(vertexId, newPosition);
      
      // 世界データを更新
      if (this._world) {
        const vertexIndex = this._world.vertices.findIndex(v => v.id === vertexId);
        if (vertexIndex !== -1) {
          this._world.vertices[vertexIndex] = result.vertex;
        }
        
        // 影響を受けた特徴を更新
        for (const feature of result.affectedFeatures) {
          const featureIndex = this._world.features.findIndex(f => f.id === feature.id);
          if (featureIndex !== -1) {
            this._world.features[featureIndex] = feature;
          }
        }
      }
      
      // 選択された頂点も更新
      if (this._selectedVertices.some(v => v.id === vertexId)) {
        this._selectedVertices = this._selectedVertices.map(v => 
          v.id === vertexId ? result.vertex : v
        );
        this._notifyObservers('selectedVertices');
      }
      
      // ホバー中の頂点も更新
      if (this._hoveredVertex && this._hoveredVertex.id === vertexId) {
        this._hoveredVertex = result.vertex;
        this._notifyObservers('hoveredVertex');
      }
      
      // 特徴をリロード
      await this._loadFeaturesForCurrentTime();
      
      return result;
    } catch (error) {
      console.error('頂点の移動に失敗しました', error);
      throw error;
    }
  }

  /**
   * 特徴プロパティを更新
   * @param {string} featureId - 更新する特徴のID
   * @param {Object} properties - 新しいプロパティ
   * @returns {Promise<Object>} 更新された特徴
   */
  async updateFeatureProperties(featureId, properties) {
    try {
      const feature = await this._editFeatureUseCase.updateFeature(featureId, { properties });
      
      // 世界データを更新
      if (this._world) {
        const index = this._world.features.findIndex(f => f.id === featureId);
        if (index !== -1) {
          this._world.features[index] = feature;
        }
      }
      
      // 選択中の特徴が更新された場合、選択も更新
      if (this._selectedFeature && this._selectedFeature.id === featureId) {
        this._selectedFeature = feature;
        this._notifyObservers('selectedFeature');
      }
      
      // 特徴をリロード
      await this._loadFeaturesForCurrentTime();
      
      return feature;
    } catch (error) {
      console.error('特徴プロパティの更新に失敗しました', error);
      throw error;
    }
  }

  /**
   * 特徴を追加
   * @param {string} featureType - 特徴タイプ ('point', 'line', 'polygon')
   * @param {Object} properties - プロパティ
   * @param {Object} geometry - 形状情報
   * @param {string} layerId - レイヤーID
   * @returns {Promise<Object>} 追加された特徴
   */
  async addFeature(featureType, properties, geometry, layerId) {
    try {
      const feature = await this._editFeatureUseCase.addFeature(
        featureType, properties, geometry, layerId
      );
      
      // イベントを発行
      this._eventBus.publish('FeatureAdded', { feature });
      
      return feature;
    } catch (error) {
      console.error('特徴の追加に失敗しました', error);
      throw error;
    }
  }

  /**
   * 特徴を削除
   * @param {string} featureId - 削除する特徴のID
   * @returns {Promise<void>}
   */
  async deleteFeature(featureId) {
    try {
      await this._editFeatureUseCase.deleteFeature(featureId);
      
      // イベントを発行
      this._eventBus.publish('FeatureDeleted', { featureId });
    } catch (error) {
      console.error('特徴の削除に失敗しました', error);
      throw error;
    }
  }

  /**
   * 2点間の距離を計算
   * @param {Object} point1 - 点1 { x, y }
   * @param {Object} point2 - 点2 { x, y }
   * @param {number} equatorLength - 赤道長（km）
   * @returns {Object} 距離情報 { linear, greatCircle }
   */
  calculateDistance(point1, point2, equatorLength) {
    const linearDistance = this._geometryService.calculateLinearDistanceInKm(
      point1.x, point1.y, point2.x, point2.y, equatorLength
    );
    
    const greatCircleDistance = this._geometryService.calculateGreatCircleDistance(
      point1.x, point1.y, point2.x, point2.y
    );
    
    return {
      linear: linearDistance,
      greatCircle: greatCircleDistance
    };
  }

  /**
   * 多角形の面積を計算
   * @param {string[]} vertexIds - 頂点IDの配列
   * @param {number} equatorLength - 赤道長（km）
   * @returns {number} 面積（km²）
   */
  calculatePolygonArea(vertexIds, equatorLength) {
    if (!this._world || !vertexIds || vertexIds.length < 3) return 0;
    
    const vertices = vertexIds
      .map(id => this._world.vertices.find(v => v.id === id))
      .filter(v => v);
    
    return this._geometryService.calculatePolygonAreaInKm2(vertices, equatorLength);
  }

  /**
   * 観測者を登録
   * @param {Function} observer - コールバック関数 (type, data) => void
   */
  addObserver(observer) {
    if (!this._observers.includes(observer)) {
      this._observers.push(observer);
    }
  }

  /**
   * 観測者を削除
   * @param {Function} observer - 削除する観測者
   */
  removeObserver(observer) {
    const index = this._observers.indexOf(observer);
    if (index !== -1) {
      this._observers.splice(index, 1);
    }
  }

  /**
   * 観測者に通知
   * @param {string} type - 変更タイプ
   * @private
   */
  _notifyObservers(type) {
    const data = this._getStateForType(type);
    for (const observer of this._observers) {
      observer(type, data);
    }
  }

  /**
   * タイプに応じた状態データを取得
   * @param {string} type - 変更タイプ
   * @returns {*} 状態データ
   * @private
   */
  _getStateForType(type) {
    switch (type) {
      case 'world':
        return this._world;
      case 'features':
        return this._features;
      case 'selectedFeature':
        return this._selectedFeature;
      case 'selectedVertices':
        return this._selectedVertices;
      case 'hoveredFeature':
        return this._hoveredFeature;
      case 'hoveredVertex':
        return this._hoveredVertex;
      case 'layers':
        return this._world ? this._world.layers : [];
      default:
        return null;
    }
  }

  /**
   * 世界データを取得
   * @returns {Object} 世界データ
   */
  getWorld() {
    return this._world;
  }

  /**
   * 現在表示中の特徴を取得
   * @returns {Array} 特徴の配列
   */
  getFeatures() {
    return this._features;
  }

  /**
   * 選択中の特徴を取得
   * @returns {Object} 選択中の特徴
   */
  getSelectedFeature() {
    return this._selectedFeature;
  }

  /**
   * 選択中の頂点を取得
   * @returns {Array} 選択中の頂点の配列
   */
  getSelectedVertices() {
    return this._selectedVertices;
  }

  /**
   * ホバー中の特徴を取得
   * @returns {Object} ホバー中の特徴
   */
  getHoveredFeature() {
    return this._hoveredFeature;
  }

  /**
   * ホバー中の頂点を取得
   * @returns {Object} ホバー中の頂点
   */
  getHoveredVertex() {
    return this._hoveredVertex;
  }
}

// src/presentation/view-models/TimelineViewModel.js
/**
 * タイムラインビューのデータと状態管理
 */
export class TimelineViewModel {
  /**
   * タイムラインビューモデルを作成
   * @param {NavigateTimeUseCase} navigateTimeUseCase - 時間移動ユースケース
   * @param {EventBus} eventBus - イベントバス
   */
  constructor(navigateTimeUseCase, eventBus) {
    this._navigateTimeUseCase = navigateTimeUseCase;
    this._eventBus = eventBus;
    
    // タイムラインの状態
    this._currentTime = navigateTimeUseCase.getCurrentTime();
    this._minYear = 0;
    this._maxYear = 10000;
    this._yearMarks = [];
    this._isPlaying = false;
    this._playbackSpeed = 1;
    this._playbackInterval = null;
    
    // 観測者の登録
    this._observers = [];
  }

  /**
   * 初期化
   * @param {Object} config - 設定
   */
  initialize(config) {
    this._minYear = config.minYear || 0;
    this._maxYear = config.maxYear || 10000;
    this._yearMarks = config.yearMarks || [];
    
    this._notifyObservers('range');
  }

  /**
   * 現在の時間を取得
   * @returns {TimePoint} 現在の時間点
   */
  getCurrentTime() {
    return this._currentTime;
  }

  /**
   * 時間範囲を取得
   * @returns {Object} 時間範囲 { minYear, maxYear }
   */
  getTimeRange() {
    return {
      minYear: this._minYear,
      maxYear: this._maxYear
    };
  }

  /**
   * 特定の時間に移動
   * @param {number} year - 年
   * @param {number} [month] - 月
   * @param {number} [day] - 日
   */
  moveToTime(year, month, day) {
    // 範囲の制約を適用
    const constrainedYear = Math.max(this._minYear, Math.min(this._maxYear, year));
    
    this._currentTime = this._navigateTimeUseCase.moveToTime(constrainedYear, month, day);
    
    // イベントを発行
    this._eventBus.publish('TimeChanged', { time: this._currentTime });
    
    this._notifyObservers('currentTime');
  }

  /**
   * 前進
   * @param {number} [years=1] - 進める年数
   */
  stepForward(years = 1) {
    const currentYear = this._currentTime.year;
    this.moveToTime(currentYear + years, this._currentTime.month, this._currentTime.day);
  }

  /**
   * 後退
   * @param {number} [years=1] - 戻す年数
   */
  stepBackward(years = 1) {
    const currentYear = this._currentTime.year;
    this.moveToTime(currentYear - years, this._currentTime.month, this._currentTime.day);
  }

  /**
   * 再生開始
   * @param {number} [speed=1] - 再生速度（年/秒）
   */
  startPlayback(speed = 1) {
    if (this._isPlaying) {
      this.stopPlayback();
    }
    
    this._isPlaying = true;
    this._playbackSpeed = speed;
    
    // 100ミリ秒ごとに再生
    const stepSize = this._playbackSpeed / 10;
    this._playbackInterval = setInterval(() => {
      this.stepForward(stepSize);
      
      // 最大年に達したら停止
      if (this._currentTime.year >= this._maxYear) {
        this.stopPlayback();
      }
    }, 100);
    
    this._notifyObservers('playback');
  }

  /**
   * 再生停止
   */
  stopPlayback() {
    if (this._playbackInterval) {
      clearInterval(this._playbackInterval);
      this._playbackInterval = null;
    }
    
    this._isPlaying = false;
    this._notifyObservers('playback');
  }

  /**
   * 再生中かどうかを取得
   * @returns {boolean} 再生中ならtrue
   */
  isPlaying() {
    return this._isPlaying;
  }

  /**
   * 再生速度を取得
   * @returns {number} 再生速度
   */
  getPlaybackSpeed() {
    return this._playbackSpeed;
  }

  /**
   * 時間範囲を設定
   * @param {number} minYear - 最小年
   * @param {number} maxYear - 最大年
   */
  setTimeRange(minYear, maxYear) {
    this._minYear = minYear;
    this._maxYear = maxYear;
    
    // 現在の時間が範囲外になった場合は調整
    if (this._currentTime.year < minYear) {
      this.moveToTime(minYear);
    } else if (this._currentTime.year > maxYear) {
      this.moveToTime(maxYear);
    }
    
    this._notifyObservers('range');
  }

  /**
   * 年マークを設定
   * @param {Array} marks - 年マークの配列 [{ year, label }, ...]
   */
  setYearMarks(marks) {
    this._yearMarks = marks;
    this._notifyObservers('marks');
  }

  /**
   * 年マークを取得
   * @returns {Array} 年マークの配列
   */
  getYearMarks() {
    return this._yearMarks;
  }

  /**
   * 観測者を登録
   * @param {Function} observer - コールバック関数 (type, data) => void
   */
  addObserver(observer) {
    if (!this._observers.includes(observer)) {
      this._observers.push(observer);
    }
  }

  /**
   * 観測者を削除
   * @param {Function} observer - 削除する観測者
   */
  removeObserver(observer) {
    const index = this._observers.indexOf(observer);
    if (index !== -1) {
      this._observers.splice(index, 1);
    }
  }

  /**
   * 観測者に通知
   * @param {string} type - 変更タイプ
   * @private
   */
  _notifyObservers(type) {
    const data = this._getStateForType(type);
    for (const observer of this._observers) {
      observer(type, data);
    }
  }

  /**
   * タイプに応じた状態データを取得
   * @param {string} type - 変更タイプ
   * @returns {*} 状態データ
   * @private
   */
  _getStateForType(type) {
    switch (type) {
      case 'currentTime':
        return this._currentTime;
      case 'range':
        return { minYear: this._minYear, maxYear: this._maxYear };
      case 'marks':
        return this._yearMarks;
      case 'playback':
        return { isPlaying: this._isPlaying, speed: this._playbackSpeed };
      default:
        return null;
    }
  }
}

// src/presentation/view-models/EditingViewModel.js
/**
 * 編集関連の状態管理
 */
export class EditingViewModel {
  /**
   * 編集ビューモデルを作成
   * @param {EditFeatureUseCase} editFeatureUseCase - 地理オブジェクト編集ユースケース
   * @param {EventBus} eventBus - イベントバス
   */
  constructor(editFeatureUseCase, eventBus) {
    this._editFeatureUseCase = editFeatureUseCase;
    this._eventBus = eventBus;
    
    // 編集の状態
    this._mode = 'view'; // 'view', 'add', 'edit'
    this._tool = null; // 'point', 'line', 'polygon'
    this._addingPoints = []; // 追加中の点の配列
    this._isAddingHole = false;
    this._temporaryElements = []; // 一時的な表示要素
    
    // アンドゥ・リドゥの状態
    this._undoStack = [];
    this._redoStack = [];
    this._maxHistorySize = 100;
    
    // 観測者の登録
    this._observers = [];
  }

  /**
   * 編集モードを設定
   * @param {string} mode - モード ('view', 'add', 'edit')
   */
  setMode(mode) {
    if (this._mode !== mode) {
      // 追加作業中のデータをクリア
      if (this._mode === 'add' && this._addingPoints.length > 0) {
        this._clearAddingPoints();
      }
      
      this._mode = mode;
      this._tool = null;
      
      this._notifyObservers('mode');
    }
  }

  /**
   * 編集ツールを設定
   * @param {string} tool - ツール ('point', 'line', 'polygon', 'select', ...)
   */
  setTool(tool) {
    if (this._tool !== tool) {
      // 追加作業中のデータをクリア
      if (this._mode === 'add' && this._addingPoints.length > 0) {
        this._clearAddingPoints();
      }
      
      this._tool = tool;
      
      this._notifyObservers('tool');
    }
  }

  /**
   * 編集モードを取得
   * @returns {string} 編集モード
   */
  getMode() {
    return this._mode;
  }

  /**
   * 編集ツールを取得
   * @returns {string} 編集ツール
   */
  getTool() {
    return this._tool;
  }

  /**
   * 穴追加モードを設定
   * @param {boolean} isAddingHole - 穴追加モードかどうか
   */
  setAddingHole(isAddingHole) {
    if (this._isAddingHole !== isAddingHole) {
      this._isAddingHole = isAddingHole;
      
      if (!isAddingHole) {
        this._clearAddingPoints();
      }
      
      this._notifyObservers('addingHole');
    }
  }

  /**
   * 穴追加モードを取得
   * @returns {boolean} 穴追加モードならtrue
   */
  isAddingHole() {
    return this._isAddingHole;
  }

  /**
   * 点を追加（オブジェクト追加モード用）
   * @param {Object} point - 追加する点 { x, y }
   */
  addPoint(point) {
    if (this._mode !== 'add' || !this._tool) return;
    
    this._addingPoints.push(point);
    
    this._notifyObservers('addingPoints');
  }

  /**
   * 最後の点を削除（オブジェクト追加モード用）
   */
  removeLastPoint() {
    if (this._addingPoints.length > 0) {
      this._addingPoints.pop();
      this._notifyObservers('addingPoints');
    }
  }

  /**
   * 追加中の点をクリア
   * @private
   */
  _clearAddingPoints() {
    this._addingPoints = [];
    this._notifyObservers('addingPoints');
  }

  /**
   * 追加中の点を取得
   * @returns {Array} 追加中の点の配列
   */
  getAddingPoints() {
    return this._addingPoints;
  }

  /**
   * 特徴の追加を確定
   * @param {Object} properties - プロパティ
   * @param {string} layerId - レイヤーID
   * @returns {Promise<Object>} 追加された特徴
   */
  async confirmAddFeature(properties, layerId) {
    if (this._mode !== 'add' || !this._tool || this._addingPoints.length === 0) {
      throw new Error('特徴の追加状態ではありません');
    }
    
    try {
      let feature;
      
      // ツールタイプに応じた処理
      switch (this._tool) {
        case 'point':
          if (this._addingPoints.length !== 1) {
            throw new Error('点情報は1つの点のみを持つ必要があります');
          }
          
          feature = await this._editFeatureUseCase.addFeature(
            'point',
            [properties],
            { vertices: this._addingPoints },
            layerId
          );
          break;
          
        case 'line':
          if (this._addingPoints.length < 2) {
            throw new Error('線情報は少なくとも2つの点が必要です');
          }
          
          feature = await this._editFeatureUseCase.addFeature(
            'line',
            [properties],
            { vertices: this._addingPoints },
            layerId
          );
          break;
          
        case 'polygon':
          if (this._addingPoints.length < 3) {
            throw new Error('面情報は少なくとも3つの点が必要です');
          }
          
          feature = await this._editFeatureUseCase.addFeature(
            'polygon',
            [properties],
            { 
              vertices: this._addingPoints,
              holesVertexIds: [],
              parentId: "0"
            },
            layerId
          );
          break;
          
        default:
          throw new Error(`未対応のツールタイプ: ${this._tool}`);
      }
      
      // 操作履歴に追加
      this._addToHistory({
        type: 'add',
        featureId: feature.id,
        featureType: this._tool
      });
      
      // 追加点をクリア
      this._clearAddingPoints();
      
      // イベントを発行
      this._eventBus.publish('FeatureAdded', { feature });
      
      return feature;
    } catch (error) {
      console.error('特徴の追加に失敗しました', error);
      throw error;
    }
  }

  /**
   * 頂点を移動
   * @param {string} vertexId - 移動する頂点のID
   * @param {Object} oldPosition - 元の位置 { x, y }
   * @param {Object} newPosition - 新しい位置 { x, y }
   * @returns {Promise<Object>} 移動結果
   */
  async moveVertex(vertexId, oldPosition, newPosition) {
    try {
      const result = await this._editFeatureUseCase.moveVertex(vertexId, newPosition);
      
      // 操作履歴に追加
      this._addToHistory({
        type: 'moveVertex',
        vertexId,
        oldPosition,
        newPosition
      });
      
      return result;
    } catch (error) {
      console.error('頂点の移動に失敗しました', error);
      throw error;
    }
  }

  /**
   * 特徴を削除
   * @param {string} featureId - 削除する特徴のID
   * @param {Object} feature - 削除前の特徴データ（アンドゥ用）
   * @returns {Promise<void>}
   */
  async deleteFeature(featureId, feature) {
    try {
      await this._editFeatureUseCase.deleteFeature(featureId);
      
      // 操作履歴に追加
      this._addToHistory({
        type: 'delete',
        featureId,
        feature
      });
      
      // イベントを発行
      this._eventBus.publish('FeatureDeleted', { featureId });
    } catch (error) {
      console.error('特徴の削除に失敗しました', error);
      throw error;
    }
  }

  /**
   * 特徴プロパティを更新
   * @param {string} featureId - 更新する特徴のID
   * @param {Object} oldProperties - 古いプロパティ
   * @param {Object} newProperties - 新しいプロパティ
   * @returns {Promise<Object>} 更新された特徴
   */
  async updateFeatureProperties(featureId, oldProperties, newProperties) {
    try {
      const feature = await this._editFeatureUseCase.updateFeature(
        featureId, { properties: newProperties }
      );
      
      // 操作履歴に追加
      this._addToHistory({
        type: 'updateProperties',
        featureId,
        oldProperties,
        newProperties
      });
      
      // イベントを発行
      this._eventBus.publish('FeatureUpdated', { feature });
      
      return feature;
    } catch (error) {
      console.error('特徴プロパティの更新に失敗しました', error);
      throw error;
    }
  }

  /**
   * ポリゴンに穴を追加
   * @param {string} polygonId - ポリゴンID
   * @param {Array} holePoints - 穴の頂点配列
   * @returns {Promise<Object>} 更新されたポリゴン
   */
  async addHoleToPolygon(polygonId, holePoints) {
    try {
      if (holePoints.length < 3) {
        throw new Error('穴は少なくとも3つの点が必要です');
      }
      
      // ポリゴンを取得
      const worldRepository = this._editFeatureUseCase._worldRepository;
      const world = await worldRepository.getWorld();
      
      const polygon = world.features.find(f => f.id === polygonId);
      if (!polygon) {
        throw new Error(`ポリゴンが見つかりません: ${polygonId}`);
      }
      
      // 古い穴配列を保存（アンドゥ用）
      const oldHolesVertexIds = polygon.holesVertexIds;
      
      // 頂点を作成
      const holeVertexIds = [];
      for (const point of holePoints) {
        const vertexId = `vertex-${Date.now()}-${Math.floor(Math.random() * 10000)}`;
        world.vertices.push({
          id: vertexId,
          x: point.x,
          y: point.y
        });
        holeVertexIds.push(vertexId);
      }
      
      // 穴を追加
      const newHolesVertexIds = [...oldHolesVertexIds, holeVertexIds];
      
      // ポリゴンを更新
      const updatedPolygon = await this._editFeatureUseCase.updateFeature(
        polygonId,
        { geometry: { holesVertexIds: newHolesVertexIds } }
      );
      
      // 操作履歴に追加
      this._addToHistory({
        type: 'addHole',
        polygonId,
        oldHolesVertexIds,
        newHolesVertexIds
      });
      
      // イベントを発行
      this._eventBus.publish('FeatureUpdated', { feature: updatedPolygon });
      
      // 穴追加モードを終了
      this.setAddingHole(false);
      
      return updatedPolygon;
    } catch (error) {
      console.error('穴の追加に失敗しました', error);
      throw error;
    }
  }

  /**
   * 一時的な表示要素を追加
   * @param {Object} element - 表示要素
   */
  addTemporaryElement(element) {
    this._temporaryElements.push(element);
    this._notifyObservers('temporaryElements');
  }

  /**
   * 一時的な表示要素をクリア
   */
  clearTemporaryElements() {
    this._temporaryElements = [];
    this._notifyObservers('temporaryElements');
  }

  /**
   * 一時的な表示要素を取得
   * @returns {Array} 表示要素の配列
   */
  getTemporaryElements() {
    return this._temporaryElements;
  }

  /**
   * アンドゥ
   * @returns {Promise<void>}
   */
  async undo() {
    if (this._undoStack.length === 0) return;
    
    const operation = this._undoStack.pop();
    this._redoStack.push(operation);
    
    try {
      await this._executeReverseOperation(operation);
      this._notifyObservers('history');
    } catch (error) {
      // エラーが発生した場合、リドゥスタックから削除
      this._redoStack.pop();
      console.error('アンドゥに失敗しました', error);
      throw error;
    }
  }

  /**
   * リドゥ
   * @returns {Promise<void>}
   */
  async redo() {
    if (this._redoStack.length === 0) return;
    
    const operation = this._redoStack.pop();
    this._undoStack.push(operation);
    
    try {
      await this._executeOperation(operation);
      this._notifyObservers('history');
    } catch (error) {
      // エラーが発生した場合、アンドゥスタックから削除
      this._undoStack.pop();
      console.error('リドゥに失敗しました', error);
      throw error;
    }
  }

  /**
   * 操作履歴に追加
   * @param {Object} operation - 操作情報
   * @private
   */
  _addToHistory(operation) {
    this._undoStack.push(operation);
    
    // 履歴サイズの制限
    if (this._undoStack.length > this._maxHistorySize) {
      this._undoStack.shift();
    }
    
    // リドゥスタックをクリア
    this._redoStack = [];
    
    this._notifyObservers('history');
  }

  /**
   * 操作を実行
   * @param {Object} operation - 操作情報
   * @returns {Promise<void>}
   * @private
   */
  async _executeOperation(operation) {
    // 操作タイプに応じた処理
    switch (operation.type) {
      case 'add':
        // 特徴の再追加は未実装
        break;
        
      case 'delete':
        // 削除した特徴の復元は未実装
        break;
        
      case 'moveVertex':
        await this._editFeatureUseCase.moveVertex(
          operation.vertexId,
          operation.newPosition
        );
        break;
        
      case 'updateProperties':
        await this._editFeatureUseCase.updateFeature(
          operation.featureId,
          { properties: operation.newProperties }
        );
        break;
        
      case 'addHole':
        await this._editFeatureUseCase.updateFeature(
          operation.polygonId,
          { geometry: { holesVertexIds: operation.newHolesVertexIds } }
        );
        break;
        
      default:
        throw new Error(`未対応の操作タイプ: ${operation.type}`);
    }
  }

  /**
   * 逆操作を実行
   * @param {Object} operation - 操作情報
   * @returns {Promise<void>}
   * @private
   */
  async _executeReverseOperation(operation) {
    // 操作タイプに応じた逆処理
    switch (operation.type) {
      case 'add':
        await this._editFeatureUseCase.deleteFeature(operation.featureId);
        this._eventBus.publish('FeatureDeleted', { featureId: operation.featureId });
        break;
        
      case 'delete':
        // 削除した特徴の復元は未実装
        break;
        
      case 'moveVertex':
        await this._editFeatureUseCase.moveVertex(
          operation.vertexId,
          operation.oldPosition
        );
        break;
        
      case 'updateProperties':
        const feature = await this._editFeatureUseCase.updateFeature(
          operation.featureId,
          { properties: operation.oldProperties }
        );
        this._eventBus.publish('FeatureUpdated', { feature });
        break;
        
      case 'addHole':
        const updatedPolygon = await this._editFeatureUseCase.updateFeature(
          operation.polygonId,
          { geometry: { holesVertexIds: operation.oldHolesVertexIds } }
        );
        this._eventBus.publish('FeatureUpdated', { feature: updatedPolygon });
        break;
        
      default:
        throw new Error(`未対応の操作タイプ: ${operation.type}`);
    }
  }

  /**
   * アンドゥ可能かどうかを取得
   * @returns {boolean} アンドゥ可能ならtrue
   */
  canUndo() {
    return this._undoStack.length > 0;
  }

  /**
   * リドゥ可能かどうかを取得
   * @returns {boolean} リドゥ可能ならtrue
   */
  canRedo() {
    return this._redoStack.length > 0;
  }

  /**
   * 観測者を登録
   * @param {Function} observer - コールバック関数 (type, data) => void
   */
  addObserver(observer) {
    if (!this._observers.includes(observer)) {
      this._observers.push(observer);
    }
  }

  /**
   * 観測者を削除
   * @param {Function} observer - 削除する観測者
   */
  removeObserver(observer) {
    const index = this._observers.indexOf(observer);
    if (index !== -1) {
      this._observers.splice(index, 1);
    }
  }

  /**
   * 観測者に通知
   * @param {string} type - 変更タイプ
   * @private
   */
  _notifyObservers(type) {
    const data = this._getStateForType(type);
    for (const observer of this._observers) {
      observer(type, data);
    }
  }

  /**
   * タイプに応じた状態データを取得
   * @param {string} type - 変更タイプ
   * @returns {*} 状態データ
   * @private
   */
  _getStateForType(type) {
    switch (type) {
      case 'mode':
        return this._mode;
      case 'tool':
        return this._tool;
      case 'addingPoints':
        return this._addingPoints;
      case 'addingHole':
        return this._isAddingHole;
      case 'temporaryElements':
        return this._temporaryElements;
      case 'history':
        return {
          canUndo: this.canUndo(),
          canRedo: this.canRedo()
        };
      default:
        return null;
    }
  }
}

// src/presentation/views/MapView.js
/**
 * メインマップ表示
 */
export class MapView {
  /**
   * マップビューを作成
   * @param {HTMLElement} container - 表示コンテナ
   * @param {MapViewModel} viewModel - マップビューモデル
   * @param {EditingViewModel} editingViewModel - 編集ビューモデル
   * @param {ViewportManager} viewportManager - ビューポートマネージャー
   * @param {SVGRenderer} renderer - SVGレンダラー
   * @param {ConfigManager} configManager - 設定マネージャー
   */
  constructor(container, viewModel, editingViewModel, viewportManager, renderer, configManager) {
    this._container = container;
    this._viewModel = viewModel;
    this._editingViewModel = editingViewModel;
    this._viewportManager = viewportManager;
    this._renderer = renderer;
    this._configManager = configManager;
    
    // DOM要素
    this._mapElement = null;
    
    // 計測モードの状態
    this._isMeasuringDistance = false;
    this._measurePoints = [];
    this._measureElements = [];
    
    // マウス状態
    this._isMouseDown = false;
    this._isDragging = false;
    this._lastMousePosition = { x: 0, y: 0 };
    
    // 初期化
    this._initialize();
  }

  /**
   * 初期化
   * @private
   */
  _initialize() {
    // マップコンテナ作成
    this._mapElement = document.createElement('div');
    this._mapElement.className = 'map-container';
    this._mapElement.style.width = '100%';
    this._mapElement.style.height = '100%';
    this._mapElement.style.position = 'relative';
    this._mapElement.style.overflow = 'hidden';
    this._mapElement.style.backgroundColor = '#f0f0f0';
    
    // マップコンテナに追加
    this._container.appendChild(this._mapElement);
    
    // ビューモデルとの連携
    this._viewModel.addObserver(this._onViewModelChanged.bind(this));
    this._editingViewModel.addObserver(this._onEditingViewModelChanged.bind(this));
    
    // ビューポートの変更監視
    this._viewportManager.addListener(this._onViewportChanged.bind(this));
    
    // イベントリスナーの設定
    this._setupEventListeners();
    
    // 初回描画
    this._render();
  }

  /**
   * イベントリスナーの設定
   * @private
   */
  _setupEventListeners() {
    // マウスイベント
    this._mapElement.addEventListener('mousedown', this._onMouseDown.bind(this));
    this._mapElement.addEventListener('mousemove', this._onMouseMove.bind(this));
    this._mapElement.addEventListener('mouseup', this._onMouseUp.bind(this));
    this._mapElement.addEventListener('mouseleave', this._onMouseLeave.bind(this));
    this._mapElement.addEventListener('wheel', this._onWheel.bind(this), { passive: false });
    this._mapElement.addEventListener('dblclick', this._onDoubleClick.bind(this));
    this._mapElement.addEventListener('contextmenu', this._onContextMenu.bind(this));
    
    // タッチイベント
    this._mapElement.addEventListener('touchstart', this._onTouchStart.bind(this), { passive: false });
    this._mapElement.addEventListener('touchmove', this._onTouchMove.bind(this), { passive: false });
    this._mapElement.addEventListener('touchend', this._onTouchEnd.bind(this));
    
    // キーボードイベント
    window.addEventListener('keydown', this._onKeyDown.bind(this));
    window.addEventListener('keyup', this._onKeyUp.bind(this));
    
    // ウィンドウリサイズ
    window.addEventListener('resize', this._onResize.bind(this));
  }

  /**
   * ビューモデル変更のハンドラ
   * @param {string} type - 変更タイプ
   * @param {*} data - 変更データ
   * @private
   */
  _onViewModelChanged(type, data) {
    // タイプに応じた処理
    switch (type) {
      case 'world':
      case 'features':
      case 'selectedFeature':
      case 'selectedVertices':
      case 'hoveredFeature':
      case 'hoveredVertex':
      case 'layers':
        // 再描画
        this._render();
        break;
      
      default:
        break;
    }
  }

  /**
   * 編集ビューモデル変更のハンドラ
   * @param {string} type - 変更タイプ
   * @param {*} data - 変更データ
   * @private
   */
  _onEditingViewModelChanged(type, data) {
    // タイプに応じた処理
    switch (type) {
      case 'mode':
      case 'tool':
      case 'addingPoints':
      case 'addingHole':
      case 'temporaryElements':
        // 再描画
        this._render();
        break;
      
      default:
        break;
    }
  }

  /**
   * ビューポート変更のハンドラ
   * @param {Object} viewport - ビューポート情報
   * @private
   */
  _onViewportChanged(viewport) {
    // 再描画
    this._render();
  }

  /**
   * マップを描画
   * @private
   */
  _render() {
    const world = this._viewModel.getWorld();
    if (!world) return;
    
    const viewport = this._viewportManager.getViewport();
    const currentTime = this._navigateTimeUseCase.getCurrentTime();
    
    // レンダラーでマップを描画
    this._renderer.render(world, viewport, currentTime);
    
    // 選択要素のハイライト
    this._renderSelection();
    
    // 追加中の特徴の描画
    this._renderAddingFeature();
    
    // 一時的な表示要素の描画
    this._renderTemporaryElements();
    
    // 距離測定の描画
    this._renderDistanceMeasurement();
  }

  /**
   * 選択要素のハイライト
   * @private
   */
  _renderSelection() {
    const selectedFeature = this._viewModel.getSelectedFeature();
    const selectedVertices = this._viewModel.getSelectedVertices();
    const hoveredFeature = this._viewModel.getHoveredFeature();
    const hoveredVertex = this._viewModel.getHoveredVertex();
    
    // TODO: 選択要素のハイライト処理
  }

  /**
   * 追加中の特徴の描画
   * @private
   */
  _renderAddingFeature() {
    if (this._editingViewModel.getMode() !== 'add') return;
    
    const addingPoints = this._editingViewModel.getAddingPoints();
    if (addingPoints.length === 0) return;
    
    const tool = this._editingViewModel.getTool();
    const viewport = this._viewportManager.getViewport();
    
    // ツールタイプに応じた描画
    switch (tool) {
      case 'point':
        // 点の描画
        if (addingPoints.length === 1) {
          this._renderer.drawPoint(
            addingPoints[0].x,
            addingPoints[0].y,
            { fill: '#ff0000', radius: 6, stroke: '#ffffff', strokeWidth: 2 },
            viewport
          );
        }
        break;
        
      case 'line':
        // 線の描画
        if (addingPoints.length >= 2) {
          this._renderer.drawLine(
            addingPoints,
            { stroke: '#0000ff', strokeWidth: 3, strokeDasharray: '5,5' },
            viewport
          );
        }
        break;
        
      case 'polygon':
        // 多角形の描画
        if (addingPoints.length >= 3) {
          // 線の描画（閉じる）
          const polygonPoints = [...addingPoints, addingPoints[0]];
          this._renderer.drawLine(
            polygonPoints,
            { stroke: '#00ff00', strokeWidth: 3, strokeDasharray: '5,5' },
            viewport
          );
        } else if (addingPoints.length >= 2) {
          // 線の描画（開いた状態）
          this._renderer.drawLine(
            addingPoints,
            { stroke: '#00ff00', strokeWidth: 3, strokeDasharray: '5,5' },
            viewport
          );
        }
        break;
        
      default:
        break;
    }
    
    // 各頂点の描画
    for (const point of addingPoints) {
      this._renderer.drawPoint(
        point.x,
        point.y,
        { fill: '#ffffff', radius: 4, stroke: '#000000', strokeWidth: 1 },
        viewport
      );
    }
  }

  /**
   * 一時的な表示要素の描画
   * @private
   */
  _renderTemporaryElements() {
    const elements = this._editingViewModel.getTemporaryElements();
    // TODO: 一時的な表示要素の描画処理
  }

  /**
   * 距離測定の描画
   * @private
   */
  _renderDistanceMeasurement() {
    if (!this._isMeasuringDistance || this._measurePoints.length === 0) return;
    
    const viewport = this._viewportManager.getViewport();
    
    // 測定点の描画
    for (const point of this._measurePoints) {
      this._renderer.drawPoint(
        point.x,
        point.y,
        { fill: '#ffff00', radius: 4, stroke: '#000000', strokeWidth: 1 },
        viewport
      );
    }
    
    // 測定線の描画
    if (this._measurePoints.length >= 2) {
      this._renderer.drawLine(
        this._measurePoints,
        { stroke: '#ffff00', strokeWidth: 2, strokeDasharray: '5,5' },
        viewport
      );
      
      // 距離の計算
      const equatorLength = this._configManager.get('map.equatorLength', 40000);
      
      const distances = [];
      for (let i = 1; i < this._measurePoints.length; i++) {
        const p1 = this._measurePoints[i - 1];
        const p2 = this._measurePoints[i];
        
        const distance = this._viewModel.calculateDistance(p1, p2, equatorLength);
        distances.push(distance);
      }
      
      // 総距離
      const totalLinear = distances.reduce((sum, d) => sum + d.linear, 0);
      const totalGreatCircle = distances.reduce((sum, d) => sum + d.greatCircle, 0);
      
      // 距離表示
      const midIndex = Math.floor(this._measurePoints.length / 2);
      const midPoint = this._measurePoints[midIndex];
      
      this._renderer.drawText(
        midPoint.x,
        midPoint.y - 20,
        `直線距離: ${totalLinear.toFixed(2)} km`,
        { fontSize: 12, textColor: '#000000', textAnchor: 'middle' },
        viewport
      );
      
      this._renderer.drawText(
        midPoint.x,
        midPoint.y - 5,
        `大円距離: ${totalGreatCircle.toFixed(2)} km`,
        { fontSize: 12, textColor: '#000000', textAnchor: 'middle' },
        viewport
      );
    }
  }

  /**
   * マウスダウンのハンドラ
   * @param {MouseEvent} event - マウスイベント
   * @private
   */
  _onMouseDown(event) {
    // 右クリックは無視（コンテキストメニュー用）
    if (event.button === 2) return;
    
    const screenX = event.clientX;
    const screenY = event.clientY;
    
    this._isMouseDown = true;
    this._lastMousePosition = { x: screenX, y: screenY };
    
    // 編集モードに応じた処理
    const mode = this._editingViewModel.getMode();
    switch (mode) {
      case 'view':
        // ビューモードでは、ドラッグでパン
        this._viewportManager.startDrag(screenX, screenY);
        break;
        
      case 'add':
        // 追加モードでは、クリックで点を追加
        this._handleAddPoint(event);
        break;
        
      case 'edit':
        // 編集モードでは、クリックで選択
        this._handleSelectObject(event);
        break;
        
      default:
        break;
    }
    
    // 距離測定モード
    if (this._isMeasuringDistance) {
      this._handleAddMeasurePoint(event);
    }
  }

  /**
   * マウス移動のハンドラ
   * @param {MouseEvent} event - マウスイベント
   * @private
   */
  _onMouseMove(event) {
    const screenX = event.clientX;
    const screenY = event.clientY;
    
    if (this._isMouseDown) {
      // マウスドラッグ
      if (!this._isDragging) {
        // ドラッグ開始判定
        const dx = screenX - this._lastMousePosition.x;
        const dy = screenY - this._lastMousePosition.y;
        const dragThreshold = 5;
        
        if (Math.sqrt(dx * dx + dy * dy) > dragThreshold) {
          this._isDragging = true;
        }
      }
      
      if (this._isDragging) {
        // ドラッグ処理
        const mode = this._editingViewModel.getMode();
        
        if (mode === 'view') {
          // ビューモードでは、ドラッグでパン
          this._viewportManager.drag(screenX, screenY);
        } else if (mode === 'edit') {
          // 編集モードでは、ドラッグで移動
          this._handleDragObject(event);
        }
      }
    } else {
      // 単なるマウス移動
      this._handleMouseHover(event);
    }
    
    this._lastMousePosition = { x: screenX, y: screenY };
  }

  /**
   * マウスアップのハンドラ
   * @param {MouseEvent} event - マウスイベント
   * @private
   */
  _onMouseUp(event) {
    const mode = this._editingViewModel.getMode();
    
    if (this._isMouseDown && this._isDragging) {
      // ドラッグ終了
      if (mode === 'view') {
        this._viewportManager.endDrag();
      } else if (mode === 'edit') {
        this._handleDragEnd(event);
      }
    } else if (this._isMouseDown && !this._isDragging) {
      // クリック（ドラッグなし）
      if (mode === 'view') {
        this._handleClick(event);
      }
    }
    
    this._isMouseDown = false;
    this._isDragging = false;
  }

  /**
   * マウス離脱のハンドラ
   * @param {MouseEvent} event - マウスイベント
   * @private
   */
  _onMouseLeave(event) {
    if (this._isMouseDown) {
      const mode = this._editingViewModel.getMode();
      
      if (mode === 'view') {
        this._viewportManager.endDrag();
      }
      
      this._isMouseDown = false;
      this._isDragging = false;
    }
  }

  /**
   * ホイールのハンドラ
   * @param {WheelEvent} event - ホイールイベント
   * @private
   */
  _onWheel(event) {
    event.preventDefault();
    
    const delta = -event.deltaY;
    const zoomFactor = delta > 0 ? 0.1 : -0.1;
    
    const rect = this._mapElement.getBoundingClientRect();
    const screenX = event.clientX - rect.left;
    const screenY = event.clientY - rect.top;
    
    const worldPoint = this._viewportManager.screenToWorld(screenX, screenY);
    
    this._viewportManager.zoomAt(worldPoint.x, worldPoint.y, zoomFactor);
  }

  /**
   * ダブルクリックのハンドラ
   * @param {MouseEvent} event - マウスイベント
   * @private
   */
  _onDoubleClick(event) {
    // ダブルクリックで表示をリセット
    const screenX = event.clientX;
    const screenY = event.clientY;
    
    const rect = this._mapElement.getBoundingClientRect();
    const x = screenX - rect.left;
    const y = screenY - rect.top;
    
    const worldPoint = this._viewportManager.screenToWorld(x, y);
    
    this._viewportManager.updateViewport({
      x: worldPoint.x,
      y: worldPoint.y,
      zoom: 1
    });
  }

  /**
   * コンテキストメニューのハンドラ
   * @param {MouseEvent} event - マウスイベント
   * @private
   */
  _onContextMenu(event) {
    event.preventDefault();
    
    // 右クリックメニューの表示
    // TODO: コンテキストメニュー処理
  }

  /**
   * タッチ開始のハンドラ
   * @param {TouchEvent} event - タッチイベント
   * @private
   */
  _onTouchStart(event) {
    event.preventDefault();
    
    if (event.touches.length === 1) {
      // 単一タッチはマウスと同様の処理
      const touch = event.touches[0];
      const rect = this._mapElement.getBoundingClientRect();
      const screenX = touch.clientX - rect.left;
      const screenY = touch.clientY - rect.top;
      
      this._isMouseDown = true;
      this._lastMousePosition = { x: screenX, y: screenY };
      
      const mode = this._editingViewModel.getMode();
      if (mode === 'view') {
        this._viewportManager.startDrag(screenX, screenY);
      }
    } else if (event.touches.length === 2) {
      // ピンチ処理の準備
      // TODO: ピンチ処理
    }
  }

  /**
   * タッチ移動のハンドラ
   * @param {TouchEvent} event - タッチイベント
   * @private
   */
  _onTouchMove(event) {
    event.preventDefault();
    
    if (event.touches.length === 1) {
      // 単一タッチはマウスと同様の処理
      const touch = event.touches[0];
      const rect = this._mapElement.getBoundingClientRect();
      const screenX = touch.clientX - rect.left;
      const screenY = touch.clientY - rect.top;
      
      if (this._isMouseDown) {
        if (!this._isDragging) {
          // ドラッグ開始判定
          const dx = screenX - this._lastMousePosition.x;
          const dy = screenY - this._lastMousePosition.y;
          const dragThreshold = 5;
          
          if (Math.sqrt(dx * dx + dy * dy) > dragThreshold) {
            this._isDragging = true;
          }
        }
        
        if (this._isDragging) {
          const mode = this._editingViewModel.getMode();
          if (mode === 'view') {
            this._viewportManager.drag(screenX, screenY);
          }
        }
      }
      
      this._lastMousePosition = { x: screenX, y: screenY };
    } else if (event.touches.length === 2) {
      // ピンチ処理
      // TODO: ピンチ処理
    }
  }

  /**
   * タッチ終了のハンドラ
   * @param {TouchEvent} event - タッチイベント
   * @private
   */
  _onTouchEnd(event) {
    if (this._isMouseDown) {
      const mode = this._editingViewModel.getMode();
      
      if (mode === 'view') {
        this._viewportManager.endDrag();
      }
      
      this._isMouseDown = false;
      this._isDragging = false;
    }
  }

  /**
   * キーダウンのハンドラ
   * @param {KeyboardEvent} event - キーボードイベント
   * @private
   */
  _onKeyDown(event) {
    // ESCキーで選択解除または編集キャンセル
    if (event.key === 'Escape') {
      const mode = this._editingViewModel.getMode();
      
      if (mode === 'add' && this._editingViewModel.getAddingPoints().length > 0) {
        // 追加作業のキャンセル
        this._editingViewModel._clearAddingPoints();
      } else if (mode === 'edit' && (this._viewModel.getSelectedFeature() || this._viewModel.getSelectedVertices().length > 0)) {
        // 選択解除
        this._viewModel.clearSelection();
      } else {
        // 表示モードに戻る
        this._editingViewModel.setMode('view');
      }
    }
    
    // Deleteキーで選択要素削除
    if (event.key === 'Delete') {
      const selectedFeature = this._viewModel.getSelectedFeature();
      if (selectedFeature) {
        this._editingViewModel.deleteFeature(selectedFeature.id, selectedFeature);
      }
    }
    
    // アンドゥ・リドゥ
    if (event.ctrlKey || event.metaKey) {
      if (event.key === 'z') {
        event.preventDefault();
        if (event.shiftKey) {
          // Ctrl+Shift+Z: リドゥ
          this._editingViewModel.redo();
        } else {
          // Ctrl+Z: アンドゥ
          this._editingViewModel.undo();
        }
      } else if (event.key === 'y') {
        event.preventDefault();
        // Ctrl+Y: リドゥ
        this._editingViewModel.redo();
      }
    }
  }

  /**
   * キーアップのハンドラ
   * @param {KeyboardEvent} event - キーボードイベント
   * @private
   */
  _onKeyUp(event) {
    // キー修飾子の状態更新など
  }

  /**
   * リサイズのハンドラ
   * @private
   */
  _onResize() {
    const rect = this._container.getBoundingClientRect();
    
    // レンダラーのリサイズ
    this._renderer.resize(rect.width, rect.height);
    
    // ビューポートのリサイズ
    this._viewportManager.resize(rect.width, rect.height);
  }

  /**
   * オブジェクト選択処理
   * @param {MouseEvent} event - マウスイベント
   * @private
   */
  _handleSelectObject(event) {
    // TODO: オブジェクト選択処理
  }

  /**
   * クリック処理
   * @param {MouseEvent} event - マウスイベント
   * @private
   */
  _handleClick(event) {
    // TODO: クリック処理
  }

  /**
   * オブジェクトドラッグ処理
   * @param {MouseEvent} event - マウスイベント
   * @private
   */
  _handleDragObject(event) {
    // TODO: オブジェクトドラッグ処理
  }

  /**
   * ドラッグ終了処理
   * @param {MouseEvent} event - マウスイベント
   * @private
   */
  _handleDragEnd(event) {
    // TODO: ドラッグ終了処理
  }

  /**
   * マウスホバー処理
   * @param {MouseEvent} event - マウスイベント
   * @private
   */
  _handleMouseHover(event) {
    // TODO: マウスホバー処理
  }

  /**
   * 点追加処理
   * @param {MouseEvent} event - マウスイベント
   * @private
   */
  _handleAddPoint(event) {
    const rect = this._mapElement.getBoundingClientRect();
    const screenX = event.clientX - rect.left;
    const screenY = event.clientY - rect.top;
    
    const worldPoint = this._viewportManager.screenToWorld(screenX, screenY);
    
    this._editingViewModel.addPoint(worldPoint);
  }

  /**
   * 測定点追加処理
   * @param {MouseEvent} event - マウスイベント
   * @private
   */
  _handleAddMeasurePoint(event) {
    const rect = this._mapElement.getBoundingClientRect();
    const screenX = event.clientX - rect.left;
    const screenY = event.clientY - rect.top;
    
    const worldPoint = this._viewportManager.screenToWorld(screenX, screenY);
    
    this._measurePoints.push(worldPoint);
    this._render();
  }

  /**
   * 距離測定モードを設定
   * @param {boolean} enabled - 有効化するかどうか
   */
  setMeasuringDistance(enabled) {
    this._isMeasuringDistance = enabled;
    
    if (!enabled) {
      this._measurePoints = [];
      this._render();
    }
  }

  /**
   * 距離測定モードかどうかを取得
   * @returns {boolean} 距離測定モードならtrue
   */
  isMeasuringDistance() {
    return this._isMeasuringDistance;
  }

  /**
   * 測定結果をクリア
   */
  clearMeasurements() {
    this._measurePoints = [];
    this._render();
  }
}

// src/presentation/views/TimelineView.js
/**
 * タイムライン表示
 */
export class TimelineView {
  /**
   * タイムラインビューを作成
   * @param {HTMLElement} container - 表示コンテナ
   * @param {TimelineViewModel} viewModel - タイムラインビューモデル
   */
  constructor(container, viewModel) {
    this._container = container;
    this._viewModel = viewModel;
    
    // DOM要素
    this._timelineElement = null;
    this._sliderElement = null;
    this._yearInputElement = null;
    this._playButtonElement = null;
    
    // 初期化
    this._initialize();
  }

  /**
   * 初期化
   * @private
   */
  _initialize() {
    // タイムラインコンテナ作成
    this._timelineElement = document.createElement('div');
    this._timelineElement.className = 'timeline-container';
    this._timelineElement.style.width = '100%';
    this._timelineElement.style.padding = '10px';
    this._timelineElement.style.backgroundColor = '#f5f5f5';
    this._timelineElement.style.borderTop = '1px solid #ddd';
    
    // タイムラインの要素を作成
    this._createTimelineElements();
    
    // タイムラインコンテナに追加
    this._container.appendChild(this._timelineElement);
    
    // ビューモデルとの連携
    this._viewModel.addObserver(this._onViewModelChanged.bind(this));
    
    // 初期状態を反映
    this._updateTimelineDisplay();
  }

  /**
   * タイムライン要素の作成
   * @private
   */
  _createTimelineElements() {
    // コントロール行
    const controlRow = document.createElement('div');
    controlRow.style.display = 'flex';
    controlRow.style.alignItems = 'center';
    controlRow.style.marginBottom = '5px';
    
    // 再生ボタン
    this._playButtonElement = document.createElement('button');
    this._playButtonElement.textContent = '▶';
    this._playButtonElement.style.marginRight = '10px';
    this._playButtonElement.addEventListener('click', this._onPlayButtonClick.bind(this));
    
    // 年入力
    const yearLabel = document.createElement('span');
    yearLabel.textContent = '年: ';
    yearLabel.style.marginRight = '5px';
    
    this._yearInputElement = document.createElement('input');
    this._yearInputElement.type = 'number';
    this._yearInputElement.style.width = '80px';
    this._yearInputElement.style.marginRight = '10px';
    this._yearInputElement.addEventListener('change', this._onYearInputChange.bind(this));
    
    // 前後ボタン
    const prevButton = document.createElement('button');
    prevButton.textContent = '◀';
    prevButton.style.marginRight = '5px';
    prevButton.addEventListener('click', () => this._viewModel.stepBackward());
    
    const nextButton = document.createElement('button');
    nextButton.textContent = '▶';
    nextButton.style.marginRight = '10px';
    nextButton.addEventListener('click', () => this._viewModel.stepForward());
    
    // スピード選択
    const speedLabel = document.createElement('span');
    speedLabel.textContent = '速度: ';
    speedLabel.style.marginRight = '5px';
    
    const speedSelect = document.createElement('select');
    speedSelect.style.marginRight = '10px';
    
    const speeds = [
      { value: 0.1, label: '0.1x' },
      { value: 0.5, label: '0.5x' },
      { value: 1, label: '1x' },
      { value: 2, label: '2x' },
      { value: 5, label: '5x' },
      { value: 10, label: '10x' },
    ];
    
    speeds.forEach(speed => {
      const option = document.createElement('option');
      option.value = speed.value;
      option.textContent = speed.label;
      if (speed.value === 1) option.selected = true;
      speedSelect.appendChild(option);
    });
    
    speedSelect.addEventListener('change', e => {
      if (this._viewModel.isPlaying()) {
        this._viewModel.startPlayback(Number(e.target.value));
      }
    });
    
    // コントロール行に要素を追加
    controlRow.appendChild(this._playButtonElement);
    controlRow.appendChild(yearLabel);
    controlRow.appendChild(this._yearInputElement);
    controlRow.appendChild(prevButton);
    controlRow.appendChild(nextButton);
    controlRow.appendChild(speedLabel);
    controlRow.appendChild(speedSelect);
    
    // スライダー行
    const sliderRow = document.createElement('div');
    sliderRow.style.display = 'flex';
    sliderRow.style.alignItems = 'center';
    
    // 最小年ラベル
    const minYearLabel = document.createElement('span');
    minYearLabel.textContent = this._viewModel.getTimeRange().minYear;
    minYearLabel.style.marginRight = '10px';
    minYearLabel.style.minWidth = '40px';
    minYearLabel.style.textAlign = 'right';
    
    // スライダー
    this._sliderElement = document.createElement('input');
    this._sliderElement.type = 'range';
    this._sliderElement.min = this._viewModel.getTimeRange().minYear;
    this._sliderElement.max = this._viewModel.getTimeRange().maxYear;
    this._sliderElement.step = 1;
    this._sliderElement.value = this._viewModel.getCurrentTime().year;
    this._sliderElement.style.flex = '1';
    this._sliderElement.addEventListener('input', this._onSliderChange.bind(this));
    
    // 最大年ラベル
    const maxYearLabel = document.createElement('span');
    maxYearLabel.textContent = this._viewModel.getTimeRange().maxYear;
    maxYearLabel.style.marginLeft = '10px';
    maxYearLabel.style.minWidth = '40px';
    
    // スライダー行に要素を追加
    sliderRow.appendChild(minYearLabel);
    sliderRow.appendChild(this._sliderElement);
    sliderRow.appendChild(maxYearLabel);
    
    // タイムラインに行を追加
    this._timelineElement.appendChild(controlRow);
    this._timelineElement.appendChild(sliderRow);
  }

  /**
   * ビューモデル変更のハンドラ
   * @param {string} type - 変更タイプ
   * @param {*} data - 変更データ
   * @private
   */
  _onViewModelChanged(type, data) {
    // タイプに応じた処理
    switch (type) {
      case 'currentTime':
        this._updateTimelineDisplay();
        break;
        
      case 'range':
        this._updateTimeRange();
        break;
        
      case 'playback':
        this._updatePlaybackState();
        break;
        
      default:
        break;
    }
  }

  /**
   * タイムライン表示の更新
   * @private
   */
  _updateTimelineDisplay() {
    const currentTime = this._viewModel.getCurrentTime();
    
    // スライダーの更新
    this._sliderElement.value = currentTime.year;
    
    // 年入力の更新
    this._yearInputElement.value = currentTime.year;
  }

  /**
   * 時間範囲の更新
   * @private
   */
  _updateTimeRange() {
    const range = this._viewModel.getTimeRange();
    
    // スライダーの範囲を更新
    this._sliderElement.min = range.minYear;
    this._sliderElement.max = range.maxYear;
    
    // ラベルの更新
    const minYearLabel = this._sliderElement.previousSibling;
    const maxYearLabel = this._sliderElement.nextSibling;
    
    minYearLabel.textContent = range.minYear;
    maxYearLabel.textContent = range.maxYear;
  }

  /**
   * 再生状態の更新
   * @private
   */
  _updatePlaybackState() {
    const isPlaying = this._viewModel.isPlaying();
    
    // 再生ボタンの表示を更新
    this._playButtonElement.textContent = isPlaying ? '⏸' : '▶';
  }

  /**
   * 再生ボタンクリックのハンドラ
   * @private
   */
  _onPlayButtonClick() {
    const isPlaying = this._viewModel.isPlaying();
    
    if (isPlaying) {
      this._viewModel.stopPlayback();
    } else {
      // 速度選択を取得
      const speedSelect = this._playButtonElement.parentNode.querySelector('select');
      const speed = Number(speedSelect.value);
      
      this._viewModel.startPlayback(speed);
    }
  }

  /**
   * スライダー変更のハンドラ
   * @param {Event} event - 入力イベント
   * @private
   */
  _onSliderChange(event) {
    const year = Number(event.target.value);
    this._viewModel.moveToTime(year);
  }

  /**
   * 年入力変更のハンドラ
   * @param {Event} event - 入力イベント
   * @private
   */
  _onYearInputChange(event) {
    const year = Number(event.target.value);
    
    // 範囲内に制限
    const range = this._viewModel.getTimeRange();
    const constrainedYear = Math.max(range.minYear, Math.min(range.maxYear, year));
    
    this._viewModel.moveToTime(constrainedYear);
  }
}

// src/presentation/views/ToolbarView.js
/**
 * ツールバー表示
 */
export class ToolbarView {
  /**
   * ツールバービューを作成
   * @param {HTMLElement} container - 表示コンテナ
   * @param {EditingViewModel} editingViewModel - 編集ビューモデル
   * @param {MapView} mapView - マップビュー
   */
  constructor(container, editingViewModel, mapView) {
    this._container = container;
    this._editingViewModel = editingViewModel;
    this._mapView = mapView;
    
    // DOM要素
    this._toolbarElement = null;
    this._modeButtons = {};
    this._toolButtons = {};
    
    // 初期化
    this._initialize();
  }

  /**
   * 初期化
   * @private
   */
  _initialize() {
    // ツールバーコンテナ作成
    this._toolbarElement = document.createElement('div');
    this._toolbarElement.className = 'toolbar-container';
    this._toolbarElement.style.width = '100%';
    this._toolbarElement.style.backgroundColor = '#f0f0f0';
    this._toolbarElement.style.borderBottom = '1px solid #ddd';
    this._toolbarElement.style.padding = '5px';
    
    // ツールバーの要素を作成
    this._createToolbarElements();
    
    // ツールバーコンテナに追加
    this._container.appendChild(this._toolbarElement);
    
    // 編集ビューモデルとの連携
    this._editingViewModel.addObserver(this._onEditingViewModelChanged.bind(this));
    
    // 初期状態を反映
    this._updateToolbarDisplay();
  }

  /**
   * ツールバー要素の作成
   * @private
   */
  _createToolbarElements() {
    // モードセクション
    const modeSection = document.createElement('div');
    modeSection.className = 'toolbar-section';
    modeSection.style.display = 'inline-block';
    modeSection.style.marginRight = '20px';
    
    // モードラベル
    const modeLabel = document.createElement('span');
    modeLabel.textContent = 'モード: ';
    modeLabel.style.marginRight = '5px';
    modeSection.appendChild(modeLabel);
    
    // モードボタン
    const modes = [
      { id: 'view', label: '表示', icon: '👁' },
      { id: 'add', label: '追加', icon: '➕' },
      { id: 'edit', label: '編集', icon: '✏️' }
    ];
    
    modes.forEach(mode => {
      const button = document.createElement('button');
      button.textContent = `${mode.icon} ${mode.label}`;
      button.style.marginRight = '5px';
      button.addEventListener('click', () => this._editingViewModel.setMode(mode.id));
      
      modeSection.appendChild(button);
      this._modeButtons[mode.id] = button;
    });
    
    // ツールセクション
    const toolSection = document.createElement('div');
    toolSection.className = 'toolbar-section';
    toolSection.style.display = 'inline-block';
    toolSection.style.marginRight = '20px';
    
    // ツールラベル
    const toolLabel = document.createElement('span');
    toolLabel.textContent = 'ツール: ';
    toolLabel.style.marginRight = '5px';
    toolSection.appendChild(toolLabel);
    
    // ツールボタン（追加モード用）
    const addTools = [
      { id: 'point', label: '点', icon: '•' },
      { id: 'line', label: '線', icon: '✤' },
      { id: 'polygon', label: '面', icon: '▢' }
    ];
    
    addTools.forEach(tool => {
      const button = document.createElement('button');
      button.textContent = `${tool.icon} ${tool.label}`;
      button.style.marginRight = '5px';
      button.style.display = 'none'; // 最初は非表示
      button.addEventListener('click', () => this._editingViewModel.setTool(tool.id));
      
      toolSection.appendChild(button);
      this._toolButtons[`add-${tool.id}`] = button;
    });
    
    // ツールボタン（編集モード用）
    const editTools = [
      { id: 'select', label: '選択', icon: '◉' },
      { id: 'move', label: '移動', icon: '↔' },
      { id: 'add-hole', label: '穴追加', icon: '◎' },
      { id: 'split', label: '分割', icon: '✂' }
    ];
    
    editTools.forEach(tool => {
      const button = document.createElement('button');
      button.textContent = `${tool.icon} ${tool.label}`;
      button.style.marginRight = '5px';
      button.style.display = 'none'; // 最初は非表示
      button.addEventListener('click', () => {
        if (tool.id === 'add-hole') {
          this._editingViewModel.setAddingHole(true);
        } else {
          this._editingViewModel.setTool(tool.id);
        }
      });
      
      toolSection.appendChild(button);
      this._toolButtons[`edit-${tool.id}`] = button;
    });
    
    // ユーティリティセクション
    const utilSection = document.createElement('div');
    utilSection.className = 'toolbar-section';
    utilSection.style.display = 'inline-block';
    
    // 測定ボタン
    const measureButton = document.createElement('button');
    measureButton.textContent = '📏 距離測定';
    measureButton.style.marginRight = '5px';
    measureButton.addEventListener('click', () => {
      const isMeasuring = this._mapView.isMeasuringDistance();
      this._mapView.setMeasuringDistance(!isMeasuring);
      measureButton.style.backgroundColor = !isMeasuring ? '#ddd' : '';
    });
    utilSection.appendChild(measureButton);
    
    // 測定クリアボタン
    const clearMeasureButton = document.createElement('button');
    clearMeasureButton.textContent = '🧹 測定クリア';
    clearMeasureButton.style.marginRight = '5px';
    clearMeasureButton.addEventListener('click', () => {
      this._mapView.clearMeasurements();
    });
    utilSection.appendChild(clearMeasureButton);
    
    // グリッド表示ボタン
    const gridButton = document.createElement('button');
    gridButton.textContent = '⊞ グリッド';
    gridButton.style.marginRight = '5px';
    // グリッド表示切替処理はここでは実装しない
    utilSection.appendChild(gridButton);
    
    // アンドゥ・リドゥボタン
    const undoButton = document.createElement('button');
    undoButton.textContent = '↩ 元に戻す';
    undoButton.style.marginRight = '5px';
    undoButton.addEventListener('click', () => this._editingViewModel.undo());
    utilSection.appendChild(undoButton);
    this._toolButtons['undo'] = undoButton;
    
    const redoButton = document.createElement('button');
    redoButton.textContent = '↪ やり直し';
    redoButton.style.marginRight = '5px';
    redoButton.addEventListener('click', () => this._editingViewModel.redo());
    utilSection.appendChild(redoButton);
    this._toolButtons['redo'] = redoButton;
    
    // ツールバーにセクションを追加
    this._toolbarElement.appendChild(modeSection);
    this._toolbarElement.appendChild(toolSection);
    this._toolbarElement.appendChild(utilSection);
  }

  /**
   * 編集ビューモデル変更のハンドラ
   * @param {string} type - 変更タイプ
   * @param {*} data - 変更データ
   * @private
   */
  _onEditingViewModelChanged(type, data) {
    // タイプに応じた処理
    switch (type) {
      case 'mode':
      case 'tool':
        this._updateToolbarDisplay();
        break;
        
      case 'history':
        this._updateHistoryButtons(data);
        break;
        
      default:
        break;
    }
  }

  /**
   * ツールバー表示の更新
   * @private
   */
  _updateToolbarDisplay() {
    const mode = this._editingViewModel.getMode();
    const tool = this._editingViewModel.getTool();
    
    // モードボタンの状態を更新
    Object.keys(this._modeButtons).forEach(modeId => {
      this._modeButtons[modeId].style.backgroundColor = modeId === mode ? '#ddd' : '';
    });
    
    // ツールボタンの表示/非表示を切り替え
    Object.keys(this._toolButtons).forEach(buttonId => {
      if (buttonId.startsWith('add-')) {
        this._toolButtons[buttonId].style.display = mode === 'add' ? 'inline-block' : 'none';
      } else if (buttonId.startsWith('edit-')) {
        this._toolButtons[buttonId].style.display = mode === 'edit' ? 'inline-block' : 'none';
      }
    });
    
    // ツールボタンの選択状態を更新
    if (mode === 'add') {
      Object.keys(this._toolButtons).forEach(buttonId => {
        if (buttonId.startsWith('add-')) {
          const toolId = buttonId.substring(4); // 'add-' を除去
          this._toolButtons[buttonId].style.backgroundColor = toolId === tool ? '#ddd' : '';
        }
      });
    } else if (mode === 'edit') {
      Object.keys(this._toolButtons).forEach(buttonId => {
        if (buttonId.startsWith('edit-')) {
          const toolId = buttonId.substring(5); // 'edit-' を除去
          this._toolButtons[buttonId].style.backgroundColor = toolId === tool ? '#ddd' : '';
        }
      });
    }
  }

  /**
   * 履歴ボタンの更新
   * @param {Object} data - 履歴状態
   * @private
   */
  _updateHistoryButtons(data) {
    // アンドゥ・リドゥボタンの有効/無効を更新
    this._toolButtons['undo'].disabled = !data.canUndo;
    this._toolButtons['redo'].disabled = !data.canRedo;
  }
}

// src/presentation/views/SidebarView.js
/**
 * サイドバー表示
 */
export class SidebarView {
  /**
   * サイドバービューを作成
   * @param {HTMLElement} container - 表示コンテナ
   * @param {MapViewModel} mapViewModel - マップビューモデル
   * @param {ManageLayersUseCase} manageLayersUseCase - レイヤー管理ユースケース
   * @param {EditFeatureUseCase} editFeatureUseCase - 特徴編集ユースケース
   * @param {EventBus} eventBus - イベントバス
   */
  constructor(container, mapViewModel, manageLayersUseCase, editFeatureUseCase, eventBus) {
    this._container = container;
    this._mapViewModel = mapViewModel;
    this._manageLayersUseCase = manageLayersUseCase;
    this._editFeatureUseCase = editFeatureUseCase;
    this._eventBus = eventBus;
    
    // DOM要素
    this._sidebarElement = null;
    this._layersTabElement = null;
    this._featuresTabElement = null;
    this._propertiesTabElement = null;
    
    // 現在のタブ
    this._currentTab = 'layers';
    
    // 初期化
    this._initialize();
  }

  /**
   * 初期化
   * @private
   */
  _initialize() {
    // サイドバーコンテナ作成
    this._sidebarElement = document.createElement('div');
    this._sidebarElement.className = 'sidebar-container';
    this._sidebarElement.style.width = '100%';
    this._sidebarElement.style.height = '100%';
    this._sidebarElement.style.display = 'flex';
    this._sidebarElement.style.flexDirection = 'column';
    this._sidebarElement.style.backgroundColor = '#f5f5f5';
    this._sidebarElement.style.borderLeft = '1px solid #ddd';
    
    // タブバーの作成
    this._createTabBar();
    
    // タブコンテンツの作成
    this._createLayersTab();
    this._createFeaturesTab();
    this._createPropertiesTab();
    
    // サイドバーコンテナに追加
    this._container.appendChild(this._sidebarElement);
    
    // ビューモデルとの連携
    this._mapViewModel.addObserver(this._onMapViewModelChanged.bind(this));
    
    // 初期タブを表示
    this._switchTab(this._currentTab);
  }

  /**
   * タブバーの作成
   * @private
   */
  _createTabBar() {
    const tabBar = document.createElement('div');
    tabBar.className = 'sidebar-tabs';
    tabBar.style.display = 'flex';
    tabBar.style.borderBottom = '1px solid #ddd';
    
    const tabs = [
      { id: 'layers', label: 'レイヤー' },
      { id: 'features', label: 'オブジェクト一覧' },
      { id: 'properties', label: 'プロパティ' }
    ];
    
    tabs.forEach(tab => {
      const tabElement = document.createElement('div');
      tabElement.textContent = tab.label;
      tabElement.className = 'sidebar-tab';
      tabElement.style.padding = '10px';
      tabElement.style.cursor = 'pointer';
      tabElement.style.borderRight = '1px solid #ddd';
      tabElement.addEventListener('click', () => this._switchTab(tab.id));
      
      tabBar.appendChild(tabElement);
    });
    
    this._sidebarElement.appendChild(tabBar);
  }

  /**
   * レイヤータブの作成
   * @private
   */
  _createLayersTab() {
    this._layersTabElement = document.createElement('div');
    this._layersTabElement.className = 'sidebar-tab-content';
    this._layersTabElement.style.flex = '1';
    this._layersTabElement.style.overflow = 'auto';
    this._layersTabElement.style.padding = '10px';
    this._layersTabElement.style.display = 'none';
    
    // レイヤー一覧のコンテナ
    const layersContainer = document.createElement('div');
    layersContainer.className = 'layers-container';
    
    // レイヤー追加ボタン
    const addLayerButton = document.createElement('button');
    addLayerButton.textContent = '+ レイヤー追加';
    addLayerButton.style.marginBottom = '10px';
    addLayerButton.addEventListener('click', this._showAddLayerDialog.bind(this));
    
    this._layersTabElement.appendChild(addLayerButton);
    this._layersTabElement.appendChild(layersContainer);
    
    this._sidebarElement.appendChild(this._layersTabElement);
  }

  /**
   * 特徴一覧タブの作成
   * @private
   */
  _createFeaturesTab() {
    this._featuresTabElement = document.createElement('div');
    this._featuresTabElement.className = 'sidebar-tab-content';
    this._featuresTabElement.style.flex = '1';
    this._featuresTabElement.style.overflow = 'auto';
    this._featuresTabElement.style.padding = '10px';
    this._featuresTabElement.style.display = 'none';
    
    // 特徴一覧のコンテナ
    const featuresContainer = document.createElement('div');
    featuresContainer.className = 'features-container';
    
    // フィルター行
    const filterRow = document.createElement('div');
    filterRow.style.marginBottom = '10px';
    
    const filterLabel = document.createElement('span');
    filterLabel.textContent = 'フィルター: ';
    filterLabel.style.marginRight = '5px';
    
    const filterInput = document.createElement('input');
    filterInput.type = 'text';
    filterInput.placeholder = '名前で検索...';
    filterInput.style.width = '150px';
    filterInput.addEventListener('input', this._filterFeatures.bind(this));
    
    filterRow.appendChild(filterLabel);
    filterRow.appendChild(filterInput);
    
    this._featuresTabElement.appendChild(filterRow);
    this._featuresTabElement.appendChild(featuresContainer);
    
    this._sidebarElement.appendChild(this._featuresTabElement);
  }

  /**
   * プロパティタブの作成
   * @private
   */
  _createPropertiesTab() {
    this._propertiesTabElement = document.createElement('div');
    this._propertiesTabElement.className = 'sidebar-tab-content';
    this._propertiesTabElement.style.flex = '1';
    this._propertiesTabElement.style.overflow = 'auto';
    this._propertiesTabElement.style.padding = '10px';
    this._propertiesTabElement.style.display = 'none';
    
    // プロパティフォームのコンテナ
    const propertiesContainer = document.createElement('div');
    propertiesContainer.className = 'properties-container';
    
    // プロパティが何も選択されていない時のメッセージ
    const noSelectionMsg = document.createElement('p');
    noSelectionMsg.textContent = '特徴が選択されていません';
    propertiesContainer.appendChild(noSelectionMsg);
    
    this._propertiesTabElement.appendChild(propertiesContainer);
    
    this._sidebarElement.appendChild(this._propertiesTabElement);
  }

  /**
   * タブの切り替え
   * @param {string} tabId - タブID
   * @private
   */
  _switchTab(tabId) {
    // 現在のタブを非表示
    switch (this._currentTab) {
      case 'layers':
        this._layersTabElement.style.display = 'none';
        break;
      case 'features':
        this._featuresTabElement.style.display = 'none';
        break;
      case 'properties':
        this._propertiesTabElement.style.display = 'none';
        break;
    }
    
    // 新しいタブを表示
    switch (tabId) {
      case 'layers':
        this._layersTabElement.style.display = 'block';
        this._updateLayersTab();
        break;
      case 'features':
        this._featuresTabElement.style.display = 'block';
        this._updateFeaturesTab();
        break;
      case 'properties':
        this._propertiesTabElement.style.display = 'block';
        this._updatePropertiesTab();
        break;
    }
    
    // タブの状態を更新
    const tabs = this._sidebarElement.querySelector('.sidebar-tabs').children;
    for (let i = 0; i < tabs.length; i++) {
      if (i === ['layers', 'features', 'properties'].indexOf(tabId)) {
        tabs[i].style.backgroundColor = '#ddd';
      } else {
        tabs[i].style.backgroundColor = '';
      }
    }
    
    this._currentTab = tabId;
  }

  /**
   * マップビューモデル変更のハンドラ
   * @param {string} type - 変更タイプ
   * @param {*} data - 変更データ
   * @private
   */
  _onMapViewModelChanged(type, data) {
    // タイプに応じた処理
    switch (type) {
      case 'world':
      case 'layers':
        if (this._currentTab === 'layers') {
          this._updateLayersTab();
        }
        break;
        
      case 'features':
        if (this._currentTab === 'features') {
          this._updateFeaturesTab();
        }
        break;
        
      case 'selectedFeature':
        if (this._currentTab === 'properties') {
          this._updatePropertiesTab();
        }
        // プロパティタブに自動的に切り替え
        if (data) {
          this._switchTab('properties');
        }
        break;
        
      default:
        break;
    }
  }

  /**
   * レイヤータブの更新
   * @private
   */
  _updateLayersTab() {
    const world = this._mapViewModel.getWorld();
    if (!world) return;
    
    const layersContainer = this._layersTabElement.querySelector('.layers-container');
    layersContainer.innerHTML = '';
    
    // レイヤーを順序でソート
    const sortedLayers = [...world.layers].sort((a, b) => a.order - b.order);
    
    // レイヤー一覧の表示
    sortedLayers.forEach(layer => {
      const layerItem = document.createElement('div');
      layerItem.className = 'layer-item';
      layerItem.style.padding = '5px';
      layerItem.style.border = '1px solid #ddd';
      layerItem.style.marginBottom = '5px';
      layerItem.style.backgroundColor = '#fff';
      layerItem.style.display = 'flex';
      layerItem.style.alignItems = 'center';
      
      // 表示/非表示チェックボックス
      const visibilityCheckbox = document.createElement('input');
      visibilityCheckbox.type = 'checkbox';
      visibilityCheckbox.checked = layer.visible;
      visibilityCheckbox.style.marginRight = '5px';
      visibilityCheckbox.addEventListener('change', e => {
        this._updateLayerVisibility(layer.id, e.target.checked);
      });
      
      // レイヤー名
      const nameLabel = document.createElement('span');
      nameLabel.textContent = layer.name;
      nameLabel.style.flex = '1';
      
      // 不透明度スライダー
      const opacityLabel = document.createElement('span');
      opacityLabel.textContent = '不透明度:';
      opacityLabel.style.marginRight = '5px';
      
      const opacitySlider = document.createElement('input');
      opacitySlider.type = 'range';
      opacitySlider.min = '0';
      opacitySlider.max = '1';
      opacitySlider.step = '0.1';
      opacitySlider.value = layer.opacity;
      opacitySlider.style.width = '60px';
      opacitySlider.addEventListener('input', e => {
        this._updateLayerOpacity(layer.id, Number(e.target.value));
      });
      
      // 編集ボタン
      const editButton = document.createElement('button');
      editButton.textContent = '編集';
      editButton.style.marginLeft = '5px';
      editButton.addEventListener('click', () => {
        this._showEditLayerDialog(layer);
      });
      
      // 削除ボタン
      const deleteButton = document.createElement('button');
      deleteButton.textContent = '削除';
      deleteButton.style.marginLeft = '5px';
      deleteButton.addEventListener('click', () => {
        this._showDeleteLayerConfirm(layer);
      });
      
      // アイテムに要素を追加
      layerItem.appendChild(visibilityCheckbox);
      layerItem.appendChild(nameLabel);
      layerItem.appendChild(opacityLabel);
      layerItem.appendChild(opacitySlider);
      layerItem.appendChild(editButton);
      layerItem.appendChild(deleteButton);
      
      layersContainer.appendChild(layerItem);
    });
  }

  /**
   * 特徴一覧タブの更新
   * @private
   */
  _updateFeaturesTab() {
    const features = this._mapViewModel.getFeatures();
    const currentTime = this._mapViewModel.getCurrentTime();
    
    const featuresContainer = this._featuresTabElement.querySelector('.features-container');
    featuresContainer.innerHTML = '';
    
    // フィルター入力値を取得
    const filterInput = this._featuresTabElement.querySelector('input');
    const filterText = filterInput ? filterInput.value.toLowerCase() : '';
    
    // 特徴をフィルタリングして表示
    const filteredFeatures = this._filterFeaturesByText(features, filterText, currentTime);
    
    if (filteredFeatures.length === 0) {
      const noFeaturesMsg = document.createElement('p');
      noFeaturesMsg.textContent = '表示する特徴がありません';
      featuresContainer.appendChild(noFeaturesMsg);
      return;
    }
    
    // カテゴリーごとにグループ化
    const categorizedFeatures = this._categorizeFeaturesBy(filteredFeatures, currentTime);
    
    // カテゴリーごとに表示
    Object.keys(categorizedFeatures).forEach(category => {
      const categoryGroup = document.createElement('div');
      categoryGroup.className = 'feature-category';
      categoryGroup.style.marginBottom = '10px';
      
      // カテゴリー見出し
      const categoryHeader = document.createElement('h3');
      categoryHeader.textContent = category;
      categoryHeader.style.margin = '5px 0';
      categoryHeader.style.padding = '5px';
      categoryHeader.style.backgroundColor = '#eee';
      categoryHeader.style.cursor = 'pointer';
      
      // 折りたたみ機能
      const categoryContent = document.createElement('div');
      categoryContent.className = 'category-content';
      
      categoryHeader.addEventListener('click', () => {
        categoryContent.style.display = 
          categoryContent.style.display === 'none' ? 'block' : 'none';
      });
      
      // 特徴一覧
      categorizedFeatures[category].forEach(feature => {
        const prop = feature.getPropertyAt(currentTime);
        if (!prop) return;
        
        const featureItem = document.createElement('div');
        featureItem.className = 'feature-item';
        featureItem.style.padding = '5px';
        featureItem.style.border = '1px solid #ddd';
        featureItem.style.marginBottom = '2px';
        featureItem.style.cursor = 'pointer';
        
        // 選択状態の表示
        const selectedFeature = this._mapViewModel.getSelectedFeature();
        if (selectedFeature && selectedFeature.id === feature.id) {
          featureItem.style.backgroundColor = '#d0e0ff';
        } else {
          featureItem.style.backgroundColor = '#fff';
        }
        
        // 特徴名
        const nameLabel = document.createElement('span');
        nameLabel.textContent = prop.name || '名称なし';
        
        // クリックイベント
        featureItem.addEventListener('click', () => {
          this._mapViewModel.selectFeature(feature.id);
        });
        
        // アイテムに要素を追加
        featureItem.appendChild(nameLabel);
        categoryContent.appendChild(featureItem);
      });
      
      // グループに要素を追加
      categoryGroup.appendChild(categoryHeader);
      categoryGroup.appendChild(categoryContent);
      featuresContainer.appendChild(categoryGroup);
    });
  }

  /**
   * プロパティタブの更新
   * @private
   */
  _updatePropertiesTab() {
    const selectedFeature = this._mapViewModel.getSelectedFeature();
    const currentTime = this._mapViewModel.getCurrentTime();
    
    const propertiesContainer = this._propertiesTabElement.querySelector('.properties-container');
    propertiesContainer.innerHTML = '';
    
    if (!selectedFeature) {
      const noSelectionMsg = document.createElement('p');
      noSelectionMsg.textContent = '特徴が選択されていません';
      propertiesContainer.appendChild(noSelectionMsg);
      return;
    }
    
    // 特徴の種類を特定
    let featureType = 'unknown';
    if (selectedFeature.constructor.name === 'Point') {
      featureType = 'point';
    } else if (selectedFeature.constructor.name === 'Line') {
      featureType = 'line';
    } else if (selectedFeature.constructor.name === 'Polygon') {
      featureType = 'polygon';
    }
    
    // 特徴IDと種類
    const idRow = document.createElement('div');
    idRow.style.marginBottom = '10px';
    
    const idLabel = document.createElement('span');
    idLabel.textContent = `ID: ${selectedFeature.id}`;
    idLabel.style.fontSize = '0.8em';
    idLabel.style.color = '#666';
    
    const typeLabel = document.createElement('span');
    typeLabel.textContent = `種類: ${this._getFeatureTypeName(featureType)}`;
    typeLabel.style.fontSize = '0.8em';
    typeLabel.style.color = '#666';
    typeLabel.style.marginLeft = '10px';
    
    idRow.appendChild(idLabel);
    idRow.appendChild(typeLabel);
    propertiesContainer.appendChild(idRow);
    
    // 現在のプロパティを取得
    const currentProperty = selectedFeature.getPropertyAt(currentTime);
    
    // プロパティフォームの作成
    const form = document.createElement('form');
    form.addEventListener('submit', e => {
      e.preventDefault();
      this._saveFeatureProperties(selectedFeature.id, form);
    });
    
    // 基本プロパティ
    const basicProps = [
      { id: 'name', label: '名前', type: 'text', value: currentProperty ? currentProperty.name : '' },
      { id: 'description', label: '説明', type: 'textarea', value: currentProperty ? currentProperty.description : '' },
      { id: 'category', label: 'カテゴリ', type: 'select', value: currentProperty ? currentProperty.getAttribute('category', '') : '' }
    ];
    
    basicProps.forEach(prop => {
      const row = document.createElement('div');
      row.style.marginBottom = '10px';
      
      const label = document.createElement('label');
      label.textContent = prop.label;
      label.style.display = 'block';
      label.style.marginBottom = '5px';
      
      let input;
      
      if (prop.type === 'textarea') {
        input = document.createElement('textarea');
        input.style.width = '100%';
        input.style.height = '80px';
        input.value = prop.value;
      } else if (prop.type === 'select') {
        input = document.createElement('select');
        input.style.width = '100%';
        
        // カテゴリオプション
        const categories = this._getCategoriesForFeatureType(featureType);
        
        categories.forEach(cat => {
          const option = document.createElement('option');
          option.value = cat.id;
          option.textContent = cat.name;
          if (cat.id === prop.value) {
            option.selected = true;
          }
          input.appendChild(option);
        });
      } else {
        input = document.createElement('input');
        input.type = prop.type;
        input.style.width = '100%';
        input.value = prop.value;
      }
      
      input.name = prop.id;
      
      row.appendChild(label);
      row.appendChild(input);
      form.appendChild(row);
    });
    
    // 時間範囲
    const timeRow = document.createElement('div');
    timeRow.style.marginBottom = '10px';
    
    const timeLabel = document.createElement('label');
    timeLabel.textContent = '存在期間';
    timeLabel.style.display = 'block';
    timeLabel.style.marginBottom = '5px';
    
    const startLabel = document.createElement('span');
    startLabel.textContent = '開始: ';
    
    const startInput = document.createElement('input');
    startInput.type = 'number';
    startInput.name = 'startYear';
    startInput.style.width = '80px';
    startInput.value = currentProperty && currentProperty.startTime ? currentProperty.startTime.year : '';
    
    const endLabel = document.createElement('span');
    endLabel.textContent = ' 終了: ';
    
    const endInput = document.createElement('input');
    endInput.type = 'number';
    endInput.name = 'endYear';
    endInput.style.width = '80px';
    endInput.value = currentProperty && currentProperty.endTime ? currentProperty.endTime.year : '';
    
    timeRow.appendChild(timeLabel);
    timeRow.appendChild(startLabel);
    timeRow.appendChild(startInput);
    timeRow.appendChild(endLabel);
    timeRow.appendChild(endInput);
    form.appendChild(timeRow);
    
    // 特徴タイプに応じた追加プロパティ
    if (featureType === 'point') {
      // 点特有のプロパティ
    } else if (featureType === 'line') {
      // 線特有のプロパティ
    } else if (featureType === 'polygon') {
      // 面特有のプロパティ
    }
    
    // ボタン行
    const buttonRow = document.createElement('div');
    buttonRow.style.marginTop = '20px';
    buttonRow.style.textAlign = 'right';
    
    const deleteButton = document.createElement('button');
    deleteButton.type = 'button';
    deleteButton.textContent = '削除';
    deleteButton.style.marginRight = '10px';
    deleteButton.addEventListener('click', () => {
      this._showDeleteFeatureConfirm(selectedFeature);
    });
    
    const saveButton = document.createElement('button');
    saveButton.type = 'submit';
    saveButton.textContent = '保存';
    
    buttonRow.appendChild(deleteButton);
    buttonRow.appendChild(saveButton);
    form.appendChild(buttonRow);
    
    propertiesContainer.appendChild(form);
  }

  /**
   * レイヤー表示状態の更新
   * @param {string} layerId - レイヤーID
   * @param {boolean} visible - 表示状態
   * @private
   */
  async _updateLayerVisibility(layerId, visible) {
    try {
      const layer = await this._manageLayersUseCase.updateLayer(layerId, { visible });
      
      // イベントを発行
      this._eventBus.publish('LayerVisibilityChanged', { layerId, layer });
    } catch (error) {
      console.error('レイヤー表示状態の更新に失敗しました', error);
    }
  }

  /**
   * レイヤー不透明度の更新
   * @param {string} layerId - レイヤーID
   * @param {number} opacity - 不透明度
   * @private
   */
  async _updateLayerOpacity(layerId, opacity) {
    try {
      const layer = await this._manageLayersUseCase.updateLayer(layerId, { opacity });
      
      // イベントを発行
      this._eventBus.publish('LayerVisibilityChanged', { layerId, layer });
    } catch (error) {
      console.error('レイヤー不透明度の更新に失敗しました', error);
    }
  }

  /**
   * レイヤー追加ダイアログの表示
   * @private
   */
  _showAddLayerDialog() {
    // 簡易的なダイアログ
    const name = prompt('レイヤー名を入力してください:');
    if (name) {
      this._addLayer(name);
    }
  }

  /**
   * レイヤー編集ダイアログの表示
   * @param {Object} layer - レイヤー
   * @private
   */
  _showEditLayerDialog(layer) {
    // 簡易的なダイアログ
    const name = prompt('レイヤー名を編集してください:', layer.name);
    if (name) {
      this._updateLayerName(layer.id, name);
    }
  }

  /**
   * レイヤー削除確認の表示
   * @param {Object} layer - レイヤー
   * @private
   */
  _showDeleteLayerConfirm(layer) {
    // 簡易的な確認ダイアログ
    const confirm = window.confirm(`レイヤー「${layer.name}」を削除してもよろしいですか？`);
    if (confirm) {
      this._deleteLayer(layer.id);
    }
  }

  /**
   * 特徴削除確認の表示
   * @param {Object} feature - 特徴
   * @private
   */
  _showDeleteFeatureConfirm(feature) {
    const currentTime = this._mapViewModel.getCurrentTime();
    const property = feature.getPropertyAt(currentTime);
    const name = property ? property.name : '名称なし';
    
    // 簡易的な確認ダイアログ
    const confirm = window.confirm(`特徴「${name}」を削除してもよろしいですか？`);
    if (confirm) {
      this._mapViewModel.deleteFeature(feature.id);
    }
  }

  /**
   * レイヤー追加
   * @param {string} name - レイヤー名
   * @private
   */
  async _addLayer(name) {
    try {
      await this._manageLayersUseCase.addLayer(name);
      this._updateLayersTab();
    } catch (error) {
      console.error('レイヤーの追加に失敗しました', error);
      alert('レイヤーの追加に失敗しました: ' + error.message);
    }
  }

  /**
   * レイヤー名の更新
   * @param {string} layerId - レイヤーID
   * @param {string} name - 新しい名前
   * @private
   */
  async _updateLayerName(layerId, name) {
    try {
      await this._manageLayersUseCase.updateLayer(layerId, { name });
      this._updateLayersTab();
    } catch (error) {
      console.error('レイヤー名の更新に失敗しました', error);
      alert('レイヤー名の更新に失敗しました: ' + error.message);
    }
  }

  /**
   * レイヤーの削除
   * @param {string} layerId - レイヤーID
   * @private
   */
  async _deleteLayer(layerId) {
    try {
      await this._manageLayersUseCase.deleteLayer(layerId);
      this._updateLayersTab();
    } catch (error) {
      console.error('レイヤーの削除に失敗しました', error);
      alert('レイヤーの削除に失敗しました: ' + error.message);
    }
  }

  /**
   * 特徴プロパティの保存
   * @param {string} featureId - 特徴ID
   * @param {HTMLFormElement} form - プロパティフォーム
   * @private
   */
  async _saveFeatureProperties(featureId, form) {
    // フォームデータの収集
    const formData = new FormData(form);
    
    // 基本プロパティの取得
    const name = formData.get('name');
    const description = formData.get('description');
    const category = formData.get('category');
    
    // 時間範囲の取得
    const startYear = formData.get('startYear') ? Number(formData.get('startYear')) : null;
    const endYear = formData.get('endYear') ? Number(formData.get('endYear')) : null;
    
    // 現在の特徴を取得
    const selectedFeature = this._mapViewModel.getSelectedFeature();
    const currentTime = this._mapViewModel.getCurrentTime();
    const currentProperty = selectedFeature.getPropertyAt(currentTime);
    
    // 古いプロパティを保存（アンドゥ用）
    const oldProperties = [...selectedFeature.properties];
    
    // 新しいプロパティを作成
    // （実際の実装では、TimePoint及びPropertyクラスのインスタンスを正しく作成する必要があります）
    const newProperty = {
      timePoint: { year: currentTime.year, month: currentTime.month, day: currentTime.day },
      name,
      description,
      attributes: { category },
      startTime: startYear ? { year: startYear } : null,
      endTime: endYear ? { year: endYear } : null
    };
    
    // 既存のプロパティを更新または新しいプロパティを追加
    let newProperties;
    if (currentProperty) {
      newProperties = selectedFeature.properties.map(prop => {
        if (prop === currentProperty) {
          return newProperty;
        }
        return prop;
      });
    } else {
      newProperties = [...selectedFeature.properties, newProperty];
    }
    
    try {
      // 特徴を更新
      await this._mapViewModel.updateFeatureProperties(featureId, newProperties);
      
      alert('プロパティを保存しました');
    } catch (error) {
      console.error('プロパティの保存に失敗しました', error);
      alert('プロパティの保存に失敗しました: ' + error.message);
    }
  }

  /**
   * 特徴をテキストでフィルタリング
   * @param {Array} features - 特徴の配列
   * @param {string} text - フィルターテキスト
   * @param {Object} currentTime - 現在の時間
   * @returns {Array} フィルタリングされた特徴の配列
   * @private
   */
  _filterFeaturesByText(features, text, currentTime) {
    if (!text) return features;
    
    return features.filter(feature => {
      const property = feature.getPropertyAt(currentTime);
      if (!property) return false;
      
      // 名前または説明が検索テキストを含むか
      return (
        (property.name && property.name.toLowerCase().includes(text)) ||
        (property.description && property.description.toLowerCase().includes(text))
      );
    });
  }

  /**
   * 特徴のフィルタリング
   * @param {Event} event - 入力イベント
   * @private
   */
  _filterFeatures(event) {
    this._updateFeaturesTab();
  }

  /**
   * 特徴をカテゴリでグループ化
   * @param {Array} features - 特徴の配列
   * @param {Object} currentTime - 現在の時間
   * @returns {Object} カテゴリごとの特徴オブジェクト
   * @private
   */
  _categorizeFeaturesBy(features, currentTime) {
    const categorized = {};
    
    features.forEach(feature => {
      const property = feature.getPropertyAt(currentTime);
      if (!property) return;
      
      // カテゴリを取得（なければデフォルト）
      let category = property.getAttribute('category');
      
      if (!category) {
        // 特徴タイプに基づくデフォルトカテゴリ
        if (feature.constructor.name === 'Point') {
          category = 'point';
        } else if (feature.constructor.name === 'Line') {
          category = 'line';
        } else if (feature.constructor.name === 'Polygon') {
          category = 'polygon';
        } else {
          category = 'other';
        }
      }
      
      // カテゴリ名の表示用変換
      const categoryName = this._getCategoryDisplayName(category);
      
      // カテゴリグループに追加
      if (!categorized[categoryName]) {
        categorized[categoryName] = [];
      }
      
      categorized[categoryName].push(feature);
    });
    
    return categorized;
  }

  /**
   * カテゴリ表示名の取得
   * @param {string} category - カテゴリID
   * @returns {string} 表示名
   * @private
   */
  _getCategoryDisplayName(category) {
    const categoryMap = {
      'city': '都市',
      'town': '町村',
      'battle': '戦闘',
      'ruin': '遺跡',
      'road': '道路',
      'railway': '鉄道',
      'river': '河川',
      'trade_route': '交易路',
      'border': '国境',
      'kingdom': '王国',
      'empire': '帝国',
      'province': '地方',
      'ocean': '海洋',
      'lake': '湖沼',
      'point': '点',
      'line': '線',
      'polygon': '面',
      'other': 'その他'
    };
    
    return categoryMap[category] || category;
  }

  /**
   * 特徴種類の表示名取得
   * @param {string} type - 特徴種類
   * @returns {string} 表示名
   * @private
   */
  _getFeatureTypeName(type) {
    const typeMap = {
      'point': '点',
      'line': '線',
      'polygon': '面',
      'unknown': '不明'
    };
    
    return typeMap[type] || type;
  }

  /**
   * 特徴種類に応じたカテゴリの取得
   * @param {string} type - 特徴種類
   * @returns {Array} カテゴリの配列
   * @private
   */
  _getCategoriesForFeatureType(type) {
    // デフォルトカテゴリ
    const defaultCategories = [
      { id: '', name: '-- カテゴリなし --' }
    ];
    
    // 特徴種類に応じたカテゴリ
    switch (type) {
      case 'point':
        return [
          ...defaultCategories,
          { id: 'city', name: '都市' },
          { id: 'town', name: '町村' },
          { id: 'battle', name: '戦闘' },
          { id: 'ruin', name: '遺跡' }
        ];
        
      case 'line':
        return [
          ...defaultCategories,
          { id: 'road', name: '道路' },
          { id: 'railway', name: '鉄道' },
          { id: 'river', name: '河川' },
          { id: 'trade_route', name: '交易路' },
          { id: 'border', name: '国境' }
        ];
        
      case 'polygon':
        return [
          ...defaultCategories,
          { id: 'kingdom', name: '王国' },
          { id: 'empire', name: '帝国' },
          { id: 'province', name: '地方' },
          { id: 'ocean', name: '海洋' },
          { id: 'lake', name: '湖沼' }
        ];
        
      default:
        return defaultCategories;
    }
  }
}

// src/presentation/controllers/MapController.js
/**
 * マップ操作処理
 */
export class MapController {
  /**
   * マップコントローラを作成
   * @param {MapView} mapView - マップビュー
   * @param {MapViewModel} mapViewModel - マップビューモデル
   * @param {EditingViewModel} editingViewModel - 編集ビューモデル
   * @param {ViewportManager} viewportManager - ビューポートマネージャー
   */
  constructor(mapView, mapViewModel, editingViewModel, viewportManager) {
    this._mapView = mapView;
    this._mapViewModel = mapViewModel;
    this._editingViewModel = editingViewModel;
    this._viewportManager = viewportManager;
    
    // 初期化
    this._initialize();
  }

  /**
   * 初期化
   * @private
   */
  _initialize() {
    // 初期データのロード
    this._loadInitialData();
  }

  /**
   * 初期データのロード
   * @private
   */
  async _loadInitialData() {
    try {
      await this._mapViewModel.loadWorld();
    } catch (error) {
      console.error('世界データのロードに失敗しました', error);
    }
  }

  /**
   * 中心座標の設定
   * @param {number} x - X座標
   * @param {number} y - Y座標
   */
  setCenter(x, y) {
    this._viewportManager.setCenter(x, y);
  }

  /**
   * ズームレベルの設定
   * @param {number} zoom - ズームレベル
   */
  setZoom(zoom) {
    this._viewportManager.setZoom(zoom);
  }

  /**
   * ビューポートのリセット
   */
  resetViewport() {
    this._viewportManager.updateViewport({
      x: 0,
      y: 0,
      zoom: 1
    });
  }

  /**
   * 経度シフトの実行
   * @param {number} degrees - シフトする度数
   */
  shiftLongitude(degrees) {
    this._viewportManager.shiftLongitude(degrees);
  }

  /**
   * 特徴の追加をキャンセル
   */
  cancelAddFeature() {
    if (this._editingViewModel.getMode() === 'add') {
      this._editingViewModel._clearAddingPoints();
    }
  }
}

// src/presentation/controllers/TimelineController.js
/**
 * タイムライン操作処理
 */
export class TimelineController {
  /**
   * タイムラインコントローラを作成
   * @param {TimelineView} timelineView - タイムラインビュー
   * @param {TimelineViewModel} timelineViewModel - タイムラインビューモデル
   */
  constructor(timelineView, timelineViewModel) {
    this._timelineView = timelineView;
    this._timelineViewModel = timelineViewModel;
    
    // 初期化
    this._initialize();
  }

  /**
   * 初期化
   * @private
   */
  _initialize() {
    // 初期設定
    this._timelineViewModel.initialize({
      minYear: 0,
      maxYear: 10000,
      yearMarks: []
    });
  }

  /**
   * 時間範囲の設定
   * @param {number} minYear - 最小年
   * @param {number} maxYear - 最大年
   */
  setTimeRange(minYear, maxYear) {
    this._timelineViewModel.setTimeRange(minYear, maxYear);
  }

  /**
   * 年マークの設定
   * @param {Array} marks - 年マークの配列
   */
  setYearMarks(marks) {
    this._timelineViewModel.setYearMarks(marks);
  }

  /**
   * 再生開始
   * @param {number} [speed=1] - 再生速度
   */
  startPlayback(speed = 1) {
    this._timelineViewModel.startPlayback(speed);
  }

  /**
   * 再生停止
   */
  stopPlayback() {
    this._timelineViewModel.stopPlayback();
  }

  /**
   * 前進
   * @param {number} [years=1] - 進める年数
   */
  stepForward(years = 1) {
    this._timelineViewModel.stepForward(years);
  }

  /**
   * 後退
   * @param {number} [years=1] - 戻す年数
   */
  stepBackward(years = 1) {
    this._timelineViewModel.stepBackward(years);
  }
}

// src/presentation/controllers/ToolController.js
/**
 * 編集ツール操作処理
 */
export class ToolController {
  /**
   * ツールコントローラを作成
   * @param {ToolbarView} toolbarView - ツールバービュー
   * @param {EditingViewModel} editingViewModel - 編集ビューモデル
   */
  constructor(toolbarView, editingViewModel) {
    this._toolbarView = toolbarView;
    this._editingViewModel = editingViewModel;
    
    // 初期化
    this._initialize();
  }

  /**
   * 初期化
   * @private
   */
  _initialize() {
    // 初期モードの設定
    this._editingViewModel.setMode('view');
  }

  /**
   * モードの設定
   * @param {string} mode - モード
   */
  setMode(mode) {
    this._editingViewModel.setMode(mode);
  }

  /**
   * ツールの設定
   * @param {string} tool - ツール
   */
  setTool(tool) {
    this._editingViewModel.setTool(tool);
  }

  /**
   * アンドゥの実行
   */
  undo() {
    this._editingViewModel.undo();
  }

  /**
   * リドゥの実行
   */
  redo() {
    this._editingViewModel.redo();
  }
}

// src/presentation/EventBus.js
/**
 * コンポーネント間の通信を仲介するイベントバス
 */
export class EventBus {
  constructor() {
    this._subscribers = {};
  }

  /**
   * イベントを購読
   * @param {string} eventType - イベントタイプ
   * @param {Function} callback - コールバック関数
   */
  subscribe(eventType, callback) {
    if (!this._subscribers[eventType]) {
      this._subscribers[eventType] = [];
    }
    
    this._subscribers[eventType].push(callback);
  }

  /**
   * イベント購読の解除
   * @param {string} eventType - イベントタイプ
   * @param {Function} callback - 解除するコールバック関数
   */
  unsubscribe(eventType, callback) {
    if (!this._subscribers[eventType]) return;
    
    this._subscribers[eventType] = this._subscribers[eventType].filter(
      subscriber => subscriber !== callback
    );
  }

  /**
   * イベントの発行
   * @param {string} eventType - イベントタイプ
   * @param {Object} [payload={}] - イベントデータ
   */
  publish(eventType, payload = {}) {
    if (!this._subscribers[eventType]) return;
    
    for (const callback of this._subscribers[eventType]) {
      callback(payload);
    }
  }
}
// src/main/DependencyInjection.js
import { FileSystem } from '../infrastructure/persistence/FileSystem';
import { JSONSerializer } from '../infrastructure/persistence/JSONSerializer';
import { JSONWorldRepository } from '../infrastructure/persistence/JSONWorldRepository';
import { SVGRenderer } from '../infrastructure/rendering/SVGRenderer';
import { ViewportManager } from '../infrastructure/rendering/ViewportManager';
import { Logger } from '../infrastructure/services/Logger';
import { ConfigManager } from '../infrastructure/services/ConfigManager';

import { GeometryService } from '../domain/services/GeometryService';
import { TimeService } from '../domain/services/TimeService';
import { LayerService } from '../domain/services/LayerService';

import { EditFeatureUseCase } from '../application/usecases/EditFeatureUseCase';
import { NavigateTimeUseCase } from '../application/usecases/NavigateTimeUseCase';
import { ManageLayersUseCase } from '../application/usecases/ManageLayersUseCase';

import { MapViewModel } from '../presentation/view-models/MapViewModel';
import { TimelineViewModel } from '../presentation/view-models/TimelineViewModel';
import { EditingViewModel } from '../presentation/view-models/EditingViewModel';

import { MapView } from '../presentation/views/MapView';
import { TimelineView } from '../presentation/views/TimelineView';
import { ToolbarView } from '../presentation/views/ToolbarView';
import { SidebarView } from '../presentation/views/SidebarView';

import { MapController } from '../presentation/controllers/MapController';
import { TimelineController } from '../presentation/controllers/TimelineController';
import { ToolController } from '../presentation/controllers/ToolController';

import { EventBus } from '../presentation/EventBus';

/**
 * アプリケーションの依存性注入を管理するクラス
 */
export class DependencyInjection {
  constructor() {
    this._container = {};
  }

  /**
   * 依存性を初期化
   * @param {HTMLElement} mapContainer - マップコンテナ要素
   * @param {HTMLElement} timelineContainer - タイムラインコンテナ要素
   * @param {HTMLElement} toolbarContainer - ツールバーコンテナ要素
   * @param {HTMLElement} sidebarContainer - サイドバーコンテナ要素
   */
  initialize(mapContainer, timelineContainer, toolbarContainer, sidebarContainer) {
    // インフラストラクチャ層の依存性を登録
    this._registerInfrastructureServices();
    
    // ドメイン層の依存性を登録
    this._registerDomainServices();
    
    // アプリケーション層の依存性を登録
    this._registerApplicationServices();
    
    // プレゼンテーション層の依存性を登録
    this._registerPresentationServices(
      mapContainer,
      timelineContainer,
      toolbarContainer,
      sidebarContainer
    );
  }

  /**
   * インフラストラクチャサービスの登録
   * @private
   */
  _registerInfrastructureServices() {
    // 基本サービス
    this._container.logger = new Logger(3); // INFO レベルで初期化
    this._container.configManager = new ConfigManager();
    
    // 永続化サービス
    this._container.fileSystem = new FileSystem();
    this._container.jsonSerializer = new JSONSerializer();
    this._container.worldRepository = new JSONWorldRepository(
      this._container.fileSystem,
      this._container.jsonSerializer
    );
    
    // レンダリングサービス
    this._container.viewportManager = new ViewportManager({
      width: 800,
      height: 600,
      minZoom: 0.1,
      maxZoom: 10
    });
  }

  /**
   * ドメインサービスの登録
   * @private
   */
  _registerDomainServices() {
    this._container.geometryService = new GeometryService();
    this._container.timeService = new TimeService();
    this._container.layerService = new LayerService();
  }

  /**
   * アプリケーションサービスの登録
   * @private
   */
  _registerApplicationServices() {
    // イベントバス
    this._container.eventBus = new EventBus();
    
    // ユースケース
    this._container.editFeatureUseCase = new EditFeatureUseCase(
      this._container.worldRepository,
      this._container.geometryService,
      this._container.layerService
    );
    
    this._container.navigateTimeUseCase = new NavigateTimeUseCase(
      this._container.timeService
    );
    
    this._container.manageLayersUseCase = new ManageLayersUseCase(
      this._container.worldRepository,
      this._container.layerService
    );
  }

  /**
   * プレゼンテーションサービスの登録
   * @param {HTMLElement} mapContainer - マップコンテナ要素
   * @param {HTMLElement} timelineContainer - タイムラインコンテナ要素
   * @param {HTMLElement} toolbarContainer - ツールバーコンテナ要素
   * @param {HTMLElement} sidebarContainer - サイドバーコンテナ要素
   * @private
   */
  _registerPresentationServices(
    mapContainer,
    timelineContainer,
    toolbarContainer,
    sidebarContainer
  ) {
    // ビューモデル
    this._container.mapViewModel = new MapViewModel(
      this._container.editFeatureUseCase,
      this._container.navigateTimeUseCase,
      this._container.manageLayersUseCase,
      this._container.geometryService,
      this._container.eventBus
    );
    
    this._container.timelineViewModel = new TimelineViewModel(
      this._container.navigateTimeUseCase,
      this._container.eventBus
    );
    
    this._container.editingViewModel = new EditingViewModel(
      this._container.editFeatureUseCase,
      this._container.eventBus
    );
    
    // レンダラー
    this._container.renderer = new SVGRenderer(
      mapContainer,
      { width: mapContainer.clientWidth, height: mapContainer.clientHeight }
    );
    
    // ビュー
    this._container.mapView = new MapView(
      mapContainer,
      this._container.mapViewModel,
      this._container.editingViewModel,
      this._container.viewportManager,
      this._container.renderer,
      this._container.configManager
    );
    
    this._container.timelineView = new TimelineView(
      timelineContainer,
      this._container.timelineViewModel
    );
    
    this._container.toolbarView = new ToolbarView(
      toolbarContainer,
      this._container.editingViewModel,
      this._container.mapView
    );
    
    this._container.sidebarView = new SidebarView(
      sidebarContainer,
      this._container.mapViewModel,
      this._container.manageLayersUseCase,
      this._container.editFeatureUseCase,
      this._container.eventBus
    );
    
    // コントローラ
    this._container.mapController = new MapController(
      this._container.mapView,
      this._container.mapViewModel,
      this._container.editingViewModel,
      this._container.viewportManager
    );
    
    this._container.timelineController = new TimelineController(
      this._container.timelineView,
      this._container.timelineViewModel
    );
    
    this._container.toolController = new ToolController(
      this._container.toolbarView,
      this._container.editingViewModel
    );
  }

  /**
   * コンテナから依存性を取得
   * @param {string} name - 依存性の名前
   * @returns {*} 依存オブジェクト
   */
  get(name) {
    return this._container[name];
  }
}

// src/main/Config.js
/**
 * アプリケーション全体の設定
 */
export class Config {
  constructor() {
    // デフォルト設定
    this._config = {
      // 地図表示設定
      map: {
        zoomMin: 0.1,
        zoomMax: 10,
        gridInterval: 10,
        gridColor: "#cccccc",
        gridOpacity: 0.5,
        equatorLength: 40000 // 赤道長（km）
      },
      
      // 時間スライダー設定
      timeline: {
        minYear: 0,
        maxYear: 10000,
        stepSize: 1
      },
      
      // 自動保存設定
      autoSave: {
        enabled: true,
        interval: 300, // 秒
        maxBackups: 5
      },
      
      // UIレイアウト設定
      ui: {
        leftPanelWidth: 250,
        rightPanelWidth: 300,
        timelineHeight: 100,
        darkMode: false
      },
      
      // カスタムカレンダー設定
      calendar: {
        daysPerYear: 365.25,
        monthsPerYear: 12,
        daysPerMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
      }
    };
  }

  /**
   * 設定値を取得
   * @param {string} path - 設定パス（例: "map.zoomMax"）
   * @param {*} [defaultValue=null] - デフォルト値
   * @returns {*} 設定値
   */
  get(path, defaultValue = null) {
    const parts = path.split('.');
    let current = this._config;
    
    for (const part of parts) {
      if (current === undefined || current === null) {
        return defaultValue;
      }
      current = current[part];
    }
    
    return current !== undefined ? current : defaultValue;
  }

  /**
   * 設定を更新
   * @param {Object} updates - 更新内容
   */
  update(updates) {
    this._config = this._deepMerge(this._config, updates);
  }

  /**
   * 設定セクションを取得
   * @param {string} section - セクション名
   * @returns {Object} セクション設定
   */
  getSection(section) {
    return JSON.parse(JSON.stringify(this._config[section] || {}));
  }

  /**
   * 設定セクションを更新
   * @param {string} section - セクション名
   * @param {Object} updates - 更新内容
   */
  updateSection(section, updates) {
    if (!this._config[section]) {
      this._config[section] = {};
    }
    
    this._config[section] = this._deepMerge(this._config[section], updates);
  }

  /**
   * オブジェクトの深いマージ
   * @param {Object} target - ターゲットオブジェクト
   * @param {Object} source - ソースオブジェクト
   * @returns {Object} マージされたオブジェクト
   * @private
   */
  _deepMerge(target, source) {
    const output = { ...target };
    
    if (this._isObject(target) && this._isObject(source)) {
      Object.keys(source).forEach(key => {
        if (this._isObject(source[key])) {
          if (!(key in target)) {
            output[key] = source[key];
          } else {
            output[key] = this._deepMerge(target[key], source[key]);
          }
        } else {
          output[key] = source[key];
        }
      });
    }
    
    return output;
  }

  /**
   * オブジェクトかどうかをチェック
   * @param {*} item - チェックする項目
   * @returns {boolean} オブジェクトならtrue
   * @private
   */
  _isObject(item) {
    return (item && typeof item === 'object' && !Array.isArray(item));
  }
}

// src/main/index.js - アプリケーションのエントリーポイント
import { DependencyInjection } from './DependencyInjection';
import { Config } from './Config';

/**
 * アプリケーションのメインクラス
 */
class TimeMapApp {
  constructor() {
    this._di = new DependencyInjection();
    this._config = new Config();
    
    // 初期化済みフラグ
    this._isInitialized = false;
  }

  /**
   * アプリケーションを初期化
   */
  initialize() {
    if (this._isInitialized) {
      return;
    }
    
    // HTMLコンテナの作成
    this._createContainers();
    
    // 依存性の初期化
    this._di.initialize(
      this._mapContainer,
      this._timelineContainer,
      this._toolbarContainer,
      this._sidebarContainer
    );
    
    // 設定の適用
    this._applyConfig();
    
    // ウィンドウリサイズイベントの設定
    window.addEventListener('resize', this._handleResize.bind(this));
    
    this._isInitialized = true;
  }

  /**
   * HTMLコンテナを作成
   * @private
   */
  _createContainers() {
    // メインコンテナ
    this._mainContainer = document.getElementById('app') || document.body;
    this._mainContainer.style.display = 'flex';
    this._mainContainer.style.flexDirection = 'column';
    this._mainContainer.style.height = '100vh';
    this._mainContainer.style.overflow = 'hidden';
    
    // ツールバーコンテナ
    this._toolbarContainer = document.createElement('div');
    this._toolbarContainer.id = 'toolbar-container';
    this._toolbarContainer.style.width = '100%';
    this._toolbarContainer.style.height = '50px';
    this._mainContainer.appendChild(this._toolbarContainer);
    
    // メインエリアコンテナ（左右に分割）
    this._mainAreaContainer = document.createElement('div');
    this._mainAreaContainer.style.display = 'flex';
    this._mainAreaContainer.style.flex = '1';
    this._mainAreaContainer.style.overflow = 'hidden';
    this._mainContainer.appendChild(this._mainAreaContainer);
    
    // マップコンテナ
    this._mapContainer = document.createElement('div');
    this._mapContainer.id = 'map-container';
    this._mapContainer.style.flex = '1';
    this._mapContainer.style.position = 'relative';
    this._mainAreaContainer.appendChild(this._mapContainer);
    
    // サイドバーコンテナ
    this._sidebarContainer = document.createElement('div');
    this._sidebarContainer.id = 'sidebar-container';
    this._sidebarContainer.style.width = `${this._config.get('ui.rightPanelWidth', 300)}px`;
    this._sidebarContainer.style.height = '100%';
    this._mainAreaContainer.appendChild(this._sidebarContainer);
    
    // タイムラインコンテナ
    this._timelineContainer = document.createElement('div');
    this._timelineContainer.id = 'timeline-container';
    this._timelineContainer.style.width = '100%';
    this._timelineContainer.style.height = `${this._config.get('ui.timelineHeight', 100)}px`;
    this._mainContainer.appendChild(this._timelineContainer);
  }

  /**
   * 設定を適用
   * @private
   */
  _applyConfig() {
    // ビューポートマネージャーに設定を適用
    const viewportManager = this._di.get('viewportManager');
    viewportManager.updateViewport({
      minZoom: this._config.get('map.zoomMin', 0.1),
      maxZoom: this._config.get('map.zoomMax', 10)
    });
    
    // タイムラインコントローラに設定を適用
    const timelineController = this._di.get('timelineController');
    timelineController.setTimeRange(
      this._config.get('timeline.minYear', 0),
      this._config.get('timeline.maxYear', 10000)
    );
    
    // 時間サービスに設定を適用
    const timeService = this._di.get('timeService');
    timeService.updateCalendarConfig(this._config.get('calendar', {}));
    
    // 設定マネージャーに設定を適用
    const configManager = this._di.get('configManager');
    Object.keys(this._config._config).forEach(section => {
      configManager.updateSection(section, this._config.getSection(section));
    });
  }

  /**
   * リサイズハンドラ
   * @private
   */
  _handleResize() {
    const rect = this._mapContainer.getBoundingClientRect();
    
    // ビューポートの更新
    const viewportManager = this._di.get('viewportManager');
    viewportManager.resize(rect.width, rect.height);
    
    // レンダラーの更新
    const renderer = this._di.get('renderer');
    renderer.resize(rect.width, rect.height);
  }

  /**
   * サイドバーの幅を変更
   * @param {number} width - 新しい幅
   */
  setSidebarWidth(width) {
    this._sidebarContainer.style.width = `${width}px`;
    this._config.updateSection('ui', { rightPanelWidth: width });
    this._handleResize();
  }

  /**
   * タイムラインの高さを変更
   * @param {number} height - 新しい高さ
   */
  setTimelineHeight(height) {
    this._timelineContainer.style.height = `${height}px`;
    this._config.updateSection('ui', { timelineHeight: height });
    this._handleResize();
  }

  /**
   * ダークモードの切り替え
   * @param {boolean} enabled - 有効にするかどうか
   */
  setDarkMode(enabled) {
    if (enabled) {
      document.body.classList.add('dark-mode');
    } else {
      document.body.classList.remove('dark-mode');
    }
    
    this._config.updateSection('ui', { darkMode: enabled });
  }
}

// アプリケーションのインスタンスを作成
const app = new TimeMapApp();

// DOMコンテンツロード後に初期化
document.addEventListener('DOMContentLoaded', () => {
  app.initialize();
});

// グローバルアクセス用
window.timeMapApp = app;